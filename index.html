<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="低级Debuger">
<meta property="og:url" content="https://lyhighfly.github.io/index.html">
<meta property="og:site_name" content="低级Debuger">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="低级Debuger">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lyhighfly.github.io/"/>





  <title>低级Debuger - 是个懒蛋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">低级Debuger</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">是个懒蛋</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lyhighfly.github.io/2017/10/01/Android中LRUCache的实现分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lyhighfly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myself.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="低级Debuger">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/01/Android中LRUCache的实现分析/" itemprop="url">Android中LRUCache实现的分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-01T19:30:57+08:00">
                2017-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="什么是LRU："><a href="#什么是LRU：" class="headerlink" title="什么是LRU："></a>什么是LRU：</h4><blockquote>
<p>Least Recently Used(最近最少使用)，其思想如名称，定义一个固定size的缓存池，如果缓存内容没有超过缓存池，则所有的数据都是可以直接放入到池中的，但是如果需要缓存的对象，已经超过了缓存池的限制，则LRU会将最近最少被使用到的缓存池中的对象，驱逐出池，用于腾出空位置将新对象放入其中。</p>
</blockquote>
<h3 id="什么是LinkedHashMap："><a href="#什么是LinkedHashMap：" class="headerlink" title="什么是LinkedHashMap："></a>什么是LinkedHashMap：</h3><blockquote>
<p>内部基于双向链表，实现了Map接口的数据结构，在使用LinkedHashMap时，可以定义内部元素存储顺序，默认是按照insert的顺序，但是也可以按照访问顺序，LRUCache的实现，就是使用了LinkedHashMap的按照访问顺序特点。—<br>存储顺序按照插入顺序保存，最近读取的数据放在队列的尾部，最早读取的数据放在了队列的头部，如果当前存储的数据大小已经超过定义的最大值，则新数据插入，会将队头部的数据清除。</p>
</blockquote>
<p>Android实现的版本，是采用delegation的方式，如果使用inherition的方式，可以在外部直接使用Collections.sychorinzed(Map)的方式很方便的实现线程安全属性。而使用delegation的方式，则需要自己实现线程同步的问题(Android的版本是线程安全的)。</p>
<p>关于一个缓存工具的使用，其中必然最重要的就是get和put(add)方法的使用了，那么接下来就来分析一下其实现：</p>
<ol>
<li>LRUCache.get(K key)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Returns the value for &#123;<span class="doctag">@code</span> key&#125; if it exists in the cache or can be</div><div class="line">    * created by &#123;<span class="doctag">@code</span> #create&#125;. If a value was returned, it is moved to the</div><div class="line">    * head of the queue. This returns null if a value is not cached and cannot</div><div class="line">    * be created.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       V mapValue;</div><div class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">           mapValue = map.get(key);</div><div class="line">           <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</div><div class="line">               hitCount++;</div><div class="line">               <span class="keyword">return</span> mapValue;</div><div class="line">           &#125;</div><div class="line">           missCount++;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/**</span></div><div class="line">       在缓存未命中的情况下，可能需要create一个value值，因为此方法不是线程安全的，所以在将其插入到map中，产生冲突时，保留插入之前的值，放弃create产生的值。由此可知，在继承LRUCache的子类中，可以在缓存不命中的情况下，通过create方法，产生需要的value，而不需要put显式的插入value。</div><div class="line">       **/</div><div class="line"></div><div class="line">       V createdValue = create(key);<span class="comment">//create未实现的空方法。</span></div><div class="line">       <span class="keyword">if</span> (createdValue == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">           createCount++;</div><div class="line">           mapValue = map.put(key, createdValue);</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">// There was a conflict so undo that last put</span></div><div class="line">               map.put(key, mapValue);<span class="comment">//多线程冲突时的处理</span></div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               size += safeSizeOf(key, createdValue);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</div><div class="line">           entryRemoved(<span class="keyword">false</span>, key, createdValue, mapValue);<span class="comment">//空方法</span></div><div class="line">           <span class="keyword">return</span> mapValue;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           trimToSize(maxSize);</div><div class="line">           <span class="keyword">return</span> createdValue;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>LRUCache.put(K key, V value):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Caches &#123;<span class="doctag">@code</span> value&#125; for &#123;<span class="doctag">@code</span> key&#125;. The value is moved to the head of</div><div class="line">  * the queue.</div><div class="line">  *</div><div class="line">  * <span class="doctag">@return</span> the previous value mapped by &#123;<span class="doctag">@code</span> key&#125;.</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     V previous;</div><div class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">         putCount++;</div><div class="line">         size += safeSizeOf(key, value);</div><div class="line">         previous = map.put(key, value);</div><div class="line">         <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">             size -= safeSizeOf(key, previous);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">         entryRemoved(<span class="keyword">false</span>, key, previous, value);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     trimToSize(maxSize);</div><div class="line">     <span class="keyword">return</span> previous;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>LRUCache.remove(K key):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Removes the entry for &#123;<span class="doctag">@code</span> key&#125; if it exists.</div><div class="line">    *</div><div class="line">    * <span class="doctag">@return</span> the previous value mapped by &#123;<span class="doctag">@code</span> key&#125;.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       V previous;</div><div class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">           previous = map.remove(key);</div><div class="line">           <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">               size -= safeSizeOf(key, previous);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">           entryRemoved(<span class="keyword">false</span>, key, previous, <span class="keyword">null</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> previous;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>LRUCache.trimToSize:<br>在1，2，3方法中，都涉及到了此方法，此方法是控制缓存的关键。在初始化定义LinkedHashMap的时候，指定了maxSize，该值可以指代缓存对象的多少，也可以指代缓存对象总体占用内存的多少。而在超出maxSize的时候，就需要trimToSize方法去清理 – 最近最少使用 –的对象。</p>
<pre><code class="java"><span class="comment">/**
  * Remove the eldest entries until the total of remaining entries is at or
  * below the requested size.
  *
  * <span class="doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1
  *            to evict even 0-sized elements.
  */</span>
 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>{
     <span class="keyword">while</span> (<span class="keyword">true</span>) {
         K key;
         V value;
         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
             <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) {
                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()
                         + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);
             }

             <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) {
                 <span class="keyword">break</span>;
             }

             Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();<span class="comment">//因为每次get都会将对象放置队尾，所以迭代器开始遍历的队首就是使用最少，最优先被evict的元素。</span>
             key = toEvict.getKey();
             value = toEvict.getValue();
             map.remove(key);
             size -= safeSizeOf(key, value);
             evictionCount++;
         }

         entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);
     }
 }
</code></pre>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lyhighfly.github.io/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lyhighfly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myself.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="低级Debuger">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/" itemprop="url">Android中一种对图片展示为不同形状的处理姿势</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-29T15:11:03+08:00">
                2017-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Android UI开发中，经常会需要去展示各种各样的图片，如果只是一个新闻，一件商品的图片展示，可能产品或者美工没有什么太多的要求，默认的矩形展示就可以了。但是如果涉及到用户头像这种的，可能需要已不同于普通矩形的样式展示出来，比如说，圆角矩形，圆形等，感觉就是为了突出效果的目的呢，whatever，反正产品就要这种展示，我们苦逼的就需要去实现。<br><img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/dropface.png" alt="改版之后的快链"></p>
<h3 id="1，常规实现方式："><a href="#1，常规实现方式：" class="headerlink" title="1，常规实现方式："></a>1，常规实现方式：</h3><p>最最常规的实现方式，这个百度一下就能出来一坨，关键点就是使用了Paint.setXfermode()方法。Xfermode，这个合成词应该翻译成图像混合模式，就是用来指定使用Paint绘制的图像与原有的图像以怎样一个体位合成。<br>Xfermode有三个直接子类：</p>
<ol>
<li>AvoidXfermode //已被标注为废弃了</li>
<li>PixelXorXfermode //已被标注为废弃了</li>
<li>PorterDuffXfermode //主要使用对象</li>
</ol>
<p>于是当前主要的设置方式就是：Paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.XXX));其中的XXX有几种呢，如下：<img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/gov_demo.png" alt="PorterDuff.Mode" title="PorterDuff.Mode"></p>
<p>*图像中，dest图像为蓝色的矩形，首先被绘制；src图像为黄色的原型，最后被绘制；中间一步就是在绘制src之前的设置Paint的xfermode。各种XXX代表的意思如下：</p>
<p>   ADD:饱和相加,对图像饱和度进行相加,不常用</p>
<p>　　CLEAR:清除图像</p>
<p>　　DARKEN:变暗,较深的颜色覆盖较浅的颜色，若两者深浅程度相同则混合</p>
<p>　　DST:只显示目标图像</p>
<p>　　DST_ATOP:在源图像和目标图像相交的地方绘制【目标图像】，在不相交的地方绘制【源图像】，相交处的效果受到源图像和目标图像alpha的影响</p>
<p>　　DST_IN:只在源图像和目标图像相交的地方绘制【目标图像】，绘制效果受到源图像对应地方透明度影响</p>
<p>　　DST_OUT:只在源图像和目标图像不相交的地方绘制【目标图像】，在相交的地方根据源图像的alpha进行过滤，源图像完全不透明则完全过滤，完全透明则不过滤</p>
<p>　　DST_OVER:将目标图像放在源图像上方</p>
<p>　　LIGHTEN:变亮，与DARKEN相反，DARKEN和LIGHTEN生成的图像结果与Android对颜色值深浅的定义有关</p>
<p>　　MULTIPLY:正片叠底，源图像素颜色值乘以目标图像素颜色值除以255得到混合后图像像素颜色值</p>
<p>　　OVERLAY:叠加</p>
<p>　　SCREEN:滤色，色调均和,保留两个图层中较白的部分，较暗的部分被遮盖</p>
<p>　　SRC:只显示源图像</p>
<p>　　SRC_ATOP:在源图像和目标图像相交的地方绘制【源图像】，在不相交的地方绘制【目标图像】，相交处的效果受到源图像和目标图像alpha的影响</p>
<p>　　SRC_IN:只在源图像和目标图像相交的地方绘制【源图像】</p>
<p>　　SRC_OUT:只在源图像和目标图像不相交的地方绘制【源图像】，相交的地方根据目标图像的对应地方的alpha进行过滤，目标图像完全不透明则完全过滤，完全透明则不过滤</p>
<p>　　SRC_OVER:将源图像放在目标图像上方</p>
<p>　　XOR:在源图像和目标图像相交的地方之外绘制它们，在相交的地方受到对应alpha和色值影响，如果完全不透明则相交处完全不绘制</p>
<p>现在明确了XXX参数的含义，做出一个圆形的用户头像ImageView就不困难了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleImageView</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span></span>&#123;</div><div class="line">        canvas.drawCircle();</div><div class="line">        paint.setXfermode(PorterDuffXfermode.Mode.SRC_ATOP);</div><div class="line">        canvas.drawBitmap(Avatar, x, y, paint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大体的代码就如上，首先绘制Dest(Circle),然后设置Paint，再然后使用Avatar和这个Paint进一步绘制到canvas上，就完成了用户的圆形头像功能。<br>要十分注意这里的绘制顺序，如果顺序颠倒了，先绘制Avatar，然后设置Paint(Mode也相应的发生变化)，然后绘制Circle，就会无法达到我们需要的效果。这是为什么呢？<a href="http://www.jianshu.com/p/3feaa8b347f2" target="_blank" rel="external">android PorterDuffXferMode真正的效果测试集合（对比官方demo）</a><br>其文将两个图像的size相较于官方demo做了一些变化，然后就会得到一些大相径庭的效果，非常值得细细一看。至于上面这个问题，</p>
<p>文作者总结说：因为我们的Xfermode 叠合裁剪，都是建立在不同的层级上，重新画一个bitmap会新开一层。</p>
<p>第一种：先画circle 在canvas那层，再画Bitmap，新开了一层，中间镶嵌Xfermode，成功。</p>
<p>第二种: 先画bitmap，新开了一层，再画circle，还是在bitmap那层，中间镶嵌 Xfermode,不成功。</p>
<p>综上，如果改变了绘制顺序，想要成功的显示出想要的效果，就需要将绘制Circle这一步也产生一个Bitmap，然后将这个Bitmap绘制在Canvas上面。总之，就是需要把每一步都产生一个图层，这样xfermode才能在图层中间进行具体的操作。</p>
<p>以上，为产生圆角矩形，圆形等图像的常规步骤，一般情况下，就可以应付产品了。<center><img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/funny.png" alt="改版之后的快链"></center><br>当然，有一般，就会有二般的情况，而且这个二般的情况，处理起来还非常蛋疼。。。</p>
<h3 id="2，一种不常规的做法："><a href="#2，一种不常规的做法：" class="headerlink" title="2，一种不常规的做法："></a>2，一种不常规的做法：</h3><p>现在的产品都趋于大同，比如说底栏tab，比如说右上角的更多button，比如说圆角矩形。然后我们的产品就想着怎么做些改变，提高安装量，提高日活，这样才能有收入。浏览器首页改版，最突出的一块就剩快链了，所以，就琢么着怎么把快链做的有点新意，更美观一些，然后就给我派了不算大也不算小的活，改版快链模块，功能上没有什么大的变化，也就是能拖动调整位置，能长按编辑，删除，添加等等。这些都还好说，但是，在UI上，产品想做点改变，原先每一个快链都是圆角矩形，竞品的也多是圆角矩形，或者矩形，而我们要跟他们不一样，最终定的方案，是做成拉美曲线的outline。<br>先放一张改完版之后的lame curve版本的快链，好有个直观感受：<br><img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/new_quick_launcher.png" alt="改版之后的快链"><br>有没有感到图片确实比圆角矩形在边缘过渡的更圆滑，顺畅一些。。。</p>
<h3 id="下面就说说我苦逼实现的过程："><a href="#下面就说说我苦逼实现的过程：" class="headerlink" title="下面就说说我苦逼实现的过程："></a>下面就说说我苦逼实现的过程：</h3><p>首先，什么是lame curve，刚开始知道方案的时候，我是一脸懵逼。后来查了查，才算了解了什么是<a href="https://en.wikipedia.org/wiki/Superellipse" target="_blank" rel="external">Lame Curve</a></p>
<p>首先是lame的公式：<img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/lame_math.png" alt="lame_math">，</p>
<p>这是需要我去实现的特定lame，你们感受一下 <img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/lame_appoint.png" alt="lame_math"></p>
<p>四阶方程，两个变量，当然可以使用Path，将根据方程算出的x，y值串联起来，画在canvas上面，然后设置Paint，再将快链的原始矩形图标绘制到canvas，最终完成lame 外形的快链图标。</p>
<p>but，数学都还给老师了，即使还记得怎么求解xy，但是需要把xy都计算出来，收敛于一个固定值，精确度的问题，再加上本身我对canvas上面的绘制就不是太熟练，所以，把这个方案当成了下下策。<center><img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/godie.png" alt="lame_math"> </center></p>
<p>另外想招，可以让美工把图标都处理好，下发给我的时候已经是拉美曲线外形的了，这样移动端也省去的计算，这种方案对像淘宝，京东首页应该非常适用，因为他们的首页固定就8-10个图标，除了点击，没有给用户提供更多的交互途径，完全可以后台做完，直接下发展示就over了。但是浏览器一类的应用，首页的快链，都是可以用户自主编辑的，他完全可以自己定义一个快速链接，URL，名称完全自定义，世界上的网站千千万，每一个网站的favicon都预处理，要累死美工。<img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/verygood.png" alt="lame_math">。so，这个方案也被pass了。</p>
<blockquote>
<p>说句题外话，有时候当你想不到好的方案，对bug一筹莫展，找不到头绪的时候。适当的暂时放下来，搁置在一旁，忙一下其他的事情，有时候过一段时间回头看看，说不定就突然有了思路，知道bug在哪里了。</p>
</blockquote>
<p>走神的时候看到圆形头像的处理过程，想到既然 Circle和Avatar都可以做成Bitmap，分别绘制在Canvas上面，lame曲线跟Circle的作用是一样的，提供一个轮廓而已，完全可以让美工给做一个lame的模板，然后在绘制Avatar。</p>
<p>有了思路，赶紧当下做做试试，也许冥冥中天注定，我随手拿来写demo用的图片资源成了我能实现这个功能的关键。<br>又but，很快就遇到了问题：<br>1，之前是绘制一个Circle在Canvas上面，系统有api，很方便这样做。但是如果是读取一个lame Bitmap，然后将其绘制在Canvas上，接着在绘制另一个Bitmap，此时就会抛出异常：<em>Immutable bitmap passed to Canvas constructor</em>，什么意思呢？就是Android中不允许对res或者网络提供的图片资源进行修改，咱们第一步将lame曲线的模板图片绘制完，在绘制其他bitmap，此时就是对lame 模板的修改，系统是不允许的，当然，这个也好规避绕过去：把他存起来，在读进来，就变成Mutable的了，哈哈哈。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Converts a immutable bitmap to a mutable bitmap. This operation doesn't</div><div class="line">     * allocates more memory that there is already allocated.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> imgIn</div><div class="line">     *            - Source image. It will be released, and should not be used</div><div class="line">     *            more</div><div class="line">     * <span class="doctag">@return</span> a copy of imgIn, but muttable.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">convertToMutable</span><span class="params">(Bitmap imgIn)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// this is the file going to use temporally to save the bytes.</span></div><div class="line">        <span class="comment">// This file will not be a image, it will store the raw image data.</span></div><div class="line">        File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory()</div><div class="line">                + File.separator + <span class="string">"temp.tmp"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Open an RandomAccessFile</span></div><div class="line">        <span class="comment">// Make sure you have added uses-permission</span></div><div class="line">        <span class="comment">// android:name="android.permission.WRITE_EXTERNAL_STORAGE"</span></div><div class="line">        <span class="comment">// into AndroidManifest.xml file</span></div><div class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// get the width and height of the source bitmap.</span></div><div class="line">        <span class="keyword">int</span> width = imgIn.getWidth();</div><div class="line">        <span class="keyword">int</span> height = imgIn.getHeight();</div><div class="line">        Bitmap.Config type = imgIn.getConfig();</div><div class="line"></div><div class="line">        <span class="comment">// Copy the byte to the file</span></div><div class="line">        <span class="comment">// Assume source bitmap loaded using options.inPreferredConfig =</span></div><div class="line">        <span class="comment">// Config.ARGB_8888;</span></div><div class="line">        FileChannel channel = randomAccessFile.getChannel();</div><div class="line">        MappedByteBuffer map = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>,</div><div class="line">                imgIn.getRowBytes() * height);</div><div class="line">        imgIn.copyPixelsToBuffer(map);</div><div class="line">        <span class="comment">// recycle the source bitmap, this will be no longer used.</span></div><div class="line">        imgIn.recycle();</div><div class="line">        System.gc();<span class="comment">// try to force the bytes from the imgIn to be released</span></div><div class="line"></div><div class="line">        <span class="comment">// Create a new bitmap to load the bitmap again. Probably the memory</span></div><div class="line">        <span class="comment">// will be available.</span></div><div class="line">        imgIn = Bitmap.createBitmap(width, height, type);</div><div class="line">        map.position(<span class="number">0</span>);</div><div class="line">        <span class="comment">// load it back from temporary</span></div><div class="line">        imgIn.copyPixelsFromBuffer(map);</div><div class="line">        <span class="comment">// close the temporary file and channel , then delete that also</span></div><div class="line">        channel.close();</div><div class="line">        randomAccessFile.close();</div><div class="line"></div><div class="line">        <span class="comment">// delete the temp file</span></div><div class="line">        file.delete();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> imgIn;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>转换完lame模板，剩下的步骤就是按部就班了。</p>
<p>当时我随便在工程资源文件里面挑了一张当做lame模板<img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/test.png" alt="lame_math">，另一张当做要做曲线变换的显示图标，观察结果发现，按照我的想法，确实两者有一部分发生了交集，模板蓝色的部分，确实显示了图标，但是透明区域还是透明的，没有显示图标，没有达到想要的效果。</p>
<p>第二天我让美工给我提供了一个蓝色边线，中间非透明的lame曲线的图片，继续做实验，测试各种lame模板的搭配，比如红色边界线，白色的中间填充等等。最终发现，能达到我需要的效果的lame模板必须是，边界蓝色，中间非透明黑色的，就如下图这样：</p>
<center class="half"><br>   <img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/lame_curve_bg.png" width="100"><br>   <img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/oval_curve_bg.png" width="100"><br>   <img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/rectangle_curve_bg.png" width="100"><br>   <img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/star_curve_bg.png" width="100"><br>   <img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/triangle_curve_bg.png" width="100"><br></center>




<p>有了模板，有了原图标<img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/sogou.png" alt="tria">，那么下一步就duang的搞定了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ClipType是一个自定义的比例工具，因为我们的快链展示为原图片中间的87%，或者全size，所以做了一个转换工具，可忽略此步</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">drawTarget</span><span class="params">(Context context, Bitmap srcBitmap, <span class="keyword">float</span> scale)</span> </span>&#123;</div><div class="line">        Bitmap copyBitmap = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">int</span> mLameW = <span class="number">0</span>, mLameH = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span>(mLameCurveBitmap == <span class="keyword">null</span>)&#123;</div><div class="line">                Bitmap targetBitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.lame_curve_bg);</div><div class="line">                mLameCurveBitmap = convertToMutable(destBitmap);</div><div class="line">                mLameBgWidth = mLameCurveBitmap.getWidth();</div><div class="line">                mLameBgHeight = mLameCurveBitmap.getHeight();</div><div class="line">            &#125;</div><div class="line">            copyBitmap = Bitmap.createBitmap(mLameCurveBitmap);</div><div class="line">            mLameW = mLameBgWidth;</div><div class="line">            mLameH = mLameBgHeight;</div><div class="line">            Canvas mCanvas = <span class="keyword">new</span> Canvas(copyBitmap);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (srcBitmap != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">int</span> srcWidth = srcBitmap.getWidth();</div><div class="line">                <span class="keyword">int</span> srcHeight = srcBitmap.getHeight();</div><div class="line">                <span class="keyword">float</span> scaleX = scale*mLameW / srcWidth;</div><div class="line">                <span class="keyword">float</span> scaleY = scale*mLameH / srcHeight;</div><div class="line">                <span class="keyword">float</span> maxScale = Math.max(scaleX, scaleY);</div><div class="line"></div><div class="line">                Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line">                matrix.postScale(maxScale, maxScale);</div><div class="line">                Paint mPaint = <span class="keyword">new</span> Paint();</div><div class="line">                mPaint.setAntiAlias(<span class="keyword">true</span>);</div><div class="line">                mPaint.setColor(Color.GRAY);</div><div class="line">                mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</div><div class="line">                Bitmap srcBitmap2 = Bitmap.createBitmap(srcBitmap, <span class="number">0</span>, <span class="number">0</span>, srcWidth,</div><div class="line">                        srcHeight, matrix, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">float</span> offsetX = ClipType.getOffset(srcWidth, mLameW, maxScale, scale);</div><div class="line">                <span class="keyword">float</span> offsetY = ClipType.getOffset(srcHeight, mLameH, maxScale, scale);</div><div class="line">                mCanvas.drawBitmap(srcBitmap2, offsetX, offsetY, mPaint);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> copyBitmap;</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            <span class="keyword">return</span> getDefaultBitmap(context, scale);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当然，上述代码是针对我们项目做了调整和优化的，但也有优化上面的不足，具体情况具体分析吧，各位。</p>
<h3 id="3，Show一下做成的成果："><a href="#3，Show一下做成的成果：" class="headerlink" title="3，Show一下做成的成果："></a>3，Show一下做成的成果：</h3><p>拿着上面的各种模板，还有原始图标(本来想拿搜狗浏览器的图标呢，结果我们图标没有方的，只有圆的，做出来效果不明显，让我很方，只好给搜狗搜索做做硬广了 ：P)</p>
<p><img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/demo_result.png" alt="tria"></p>
<p>具体为什么lame模板必须是上述那样子的，我暂时还没有搞明白，<img src="/2017/09/29/Android中一种对图片展示为不同形状的处理姿势/why.png" alt="tria"><br>因为Canvas绘制都是直接native的方法，本人的c、c++也只是皮毛水平，就不想自虐了，有兴趣研究的，如果知道，劳烦告知我一下其中缘由，先谢谢了~~~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lyhighfly.github.io/2017/08/27/Android动画实现原理浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lyhighfly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myself.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="低级Debuger">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/Android动画实现原理浅析/" itemprop="url">Android动画实现原理浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-27T15:24:51+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android中的动画使用注意事项"><a href="#Android中的动画使用注意事项" class="headerlink" title="Android中的动画使用注意事项"></a>Android中的动画使用注意事项</h2><p>基本上现如今市面上所有的app，都会使用到动画效果，动画可以很好的提升用户的交互体验。</p>
<p>Android中的动画大概可以分成两个发展阶段：在Android3.0之前，Framework层提供了android.view.animation，可以实现View，ViewGroup的各种动画效果，比如AlphaAnimation，RotateAnimation，ScaleAnimation，TranslateAnimation，就可以分别实现透明度，旋转，缩放，位移等动画效果。当然，也可以通过AnimationSet将多个动画联合使用，以达到更复杂的效果。</p>
<p>为什么在Android3.0之后，就不推荐使用animation的动画了呢，是因为它大概有以下几点缺点：</p>
<ol>
<li>animation的动画，只能实现View的简单的动画效果，复杂的，比如颜色过渡无法实现；</li>
<li>animation只能操作View及其子类的可视化动画效果，但是，有可能一些非view类型的随时间轴变化的效果无法实现(layout,position的变化)；</li>
<li>animation只是简单的将view的视图信息发生了改变以达到视觉上的动画效果，但是view自身的属性没有发生根本的变化。</li>
</ol>
<p>为了弥补以上的缺点和不足，在Android3.0以上，Framework又提供了另一套动画框架：android.animation.animator。</p>
<blockquote>
<ol>
<li>Animation在动画实现的机制上与Animator是完全不同的。一句话概括就是：Animation实在每次绘制之前，通过将整块画布矩阵变换，从而实现视觉坐标系的移动、变换，但实际上其view内部记录的坐标信息以及其他属性始终没有发生变化。</li>
<li>Animator其实在动画实现上更加直接，简单一些。他是计算动画节点上对应的value，然后将此value通过不同的方式作用到view的属性参数上。（以下会有更详细的Animator机制的介绍）</li>
</ol>
</blockquote>
<p>两者的优劣对比：</p>
<ol>
<li>版本兼容性：Animation全版本支持。Animator只能支持Android3.0以上。</li>
<li>使用范围：Animation只能操作view。Animator不仅支持view动画，还可以操作多种属性的变化，任何实现相关方法的对象，都可以使用Animator来达到属性变化的过程。</li>
<li>实现效率：Animation通过画布矩阵变换处理view的动画效果。Animator则是通过对象属性set，get方法的反射调用，来达到所操作对象相关属性的变化的。因此，从效率上来说，Animation的效率可能稍高一些，而Animator由于在动画过程中要使用反射，效率稍差一些。</li>
<li>使用效果：Animation因为只是画布的矩阵变化，view的属性，位置信息并没有发生变化，所以，动画之后view的点击事件等处理都会非常麻烦。Animator因为是直接操作view的属性，在做动画的同时，view的属性也相应的发生了变化，所以不用担心view的属性与视觉上不一致的问题。</li>
</ol>
<blockquote>
<p>随着Android系统版本不断的提升，使用3.0以下系统的手机将会越来越少，时间效率。所以也就没有必要单独去深入源码分析Animation的实现原理了。而Animator是高版本一直支持的框架，因此，着重分析一下在可预见的很长一段时间内Android一直会使用的Animator的实现原理吧。</p>
</blockquote>
<h3 id="1，继承关系"><a href="#1，继承关系" class="headerlink" title="1，继承关系"></a>1，继承关系</h3><p><img src="/2017/08/27/Android动画实现原理浅析/animatorimpl.png" alt="Animator类层级"></p>
<h3 id="2-Animator的工作流程"><a href="#2-Animator的工作流程" class="headerlink" title="2, Animator的工作流程"></a>2, Animator的工作流程</h3><p><img src="/2017/08/27/Android动画实现原理浅析/anim_timeline.png" alt="Animator类层级"></p>
<h4 id="1，ObjectAnimator-ofXXX-Object-target-String-propertyName-TYPE…-values"><a href="#1，ObjectAnimator-ofXXX-Object-target-String-propertyName-TYPE…-values" class="headerlink" title="1，ObjectAnimator.ofXXX(Object target, String propertyName, TYPE… values)"></a>1，ObjectAnimator.ofXXX(Object target, String propertyName, TYPE… values)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title">ofXXX</span><span class="params">(Object target, String propertyName, XXX... values)</span> </span>&#123;</div><div class="line">    ObjectAnimator anim = <span class="keyword">new</span> ObjectAnimator(target, propertyName);</div><div class="line">    anim.setFloatValues(values);</div><div class="line">    <span class="keyword">return</span> anim;</div><div class="line">&#125;</div><div class="line">使用target创建ObjectAnimator，并使用propertyName创建PropertyValueHolder，将values值保存在PropertyValuesHolder中。</div></pre></td></tr></table></figure>
<p>setDuration等省略</p>
<h4 id="2，ObjectAnimator-start"><a href="#2，ObjectAnimator-start" class="headerlink" title="2，ObjectAnimator.start()"></a>2，ObjectAnimator.start()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">ValueAnimator</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> &#123;</div><div class="line">        <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</div><div class="line">        &#125;</div><div class="line">        AnimationHandler animationHandler = AnimationHandler.getInstance();</div><div class="line">        animationHandler.addAnimationFrameCallback(<span class="keyword">this</span>, (<span class="keyword">long</span>) (mStartDelay * sDurationScale);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mStartDelay == <span class="number">0</span> || mSeekFraction &gt;= <span class="number">0</span>) &#123;</div><div class="line">            startAnimation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="number">1</span>. 首先判断当前运行的动画的线程是否有looper，因为Animator的运行依赖looper(稍后介绍)。</div><div class="line"><span class="number">2</span>. 将当前Animator(ObjectAnimator)本身注册给AnimationHandler</div><div class="line"><span class="number">3</span>. 最后，设置一些动画标志位，完成PropertyValueHolder的一些初始化动作。</div></pre></td></tr></table></figure>
<h4 id="3，AnimationHandler-addAnimationFrameCallback"><a href="#3，AnimationHandler-addAnimationFrameCallback" class="headerlink" title="3，AnimationHandler.addAnimationFrameCallback()"></a>3，AnimationHandler.addAnimationFrameCallback()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Register to get a callback on the next frame after the delay.</div><div class="line">    */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAnimationFrameCallback</span><span class="params">(<span class="keyword">final</span> AnimationFrameCallback callback, <span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mAnimationCallbacks.size() == <span class="number">0</span>) &#123;</div><div class="line">        getProvider().postFrameCallback(mFrameCallback);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!mAnimationCallbacks.contains(callback)) &#123;</div><div class="line">        mAnimationCallbacks.add(callback);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</div><div class="line">        mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">AnimationHandler将创建的ObjectAnimator回调放入到一个ArrayList中mAnimationCallbacks，稍后在通知动画更新时，就是用此ArrayList，迭代遍历所有注册的ObjectAnimator，通知他们去更新自己的属性值。</div><div class="line"></div><div class="line">此处的Provider为MyFrameCallbackProvider</div><div class="line"><span class="comment">/**</span></div><div class="line">    * Default provider of timing pulse that uses Choreographer for frame callbacks.</div><div class="line">    */</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFrameCallbackProvider</span> <span class="keyword">implements</span> <span class="title">AnimationFrameCallbackProvider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Choreographer mChoreographer = Choreographer.getInstance();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallback</span><span class="params">(Choreographer.FrameCallback callback)</span> </span>&#123;</div><div class="line">        mChoreographer.postFrameCallback(callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCommitCallback</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">        mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getFrameTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mChoreographer.getFrameTime();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getFrameDelay</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Choreographer.getFrameDelay();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrameDelay</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">        Choreographer.setFrameDelay(delay);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Choreographer会在每次系统渲染Frame的时候，接收到一个脉冲信号，用以准备下一帧将要绘制内容的预备工作，可以在在Choreography注册监听，Choreographer.FrameCallback，在接到时间脉冲信号用于通知对此感兴趣的监听者。但是这个FrameCallback有个特别：在一个脉冲信号达到之后，这个callback就会失效，因此，如果你需要持续的监听，则需要在每次脉冲信号到达，完成自定义动作之后，再次将Callback注册一下，以便下次顺利接受回调。</div><div class="line"></div><div class="line">AnimationHanlder中定义了一个Choreographer.FrameCallback：</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">        <span class="comment">//doAnimationFrame(getProvider().getFrameTime());//稍后展开</span></div><div class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            getProvider().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">因此AnimationHandler.addAnimationFrameCallback中的写法：</div><div class="line"><span class="keyword">if</span> (mAnimationCallbacks.size() == <span class="number">0</span>) &#123;</div><div class="line">    getProvider().postFrameCallback(mFrameCallback);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!mAnimationCallbacks.contains(callback)) &#123;</div><div class="line">    mAnimationCallbacks.add(callback);</div><div class="line">&#125;</div><div class="line">意思就是统一使用一个Choreography.FrameCallback回调，如果mAnimationCallbacks不为空，表明已经有动画正在发生或者即将发生(延迟了),也就表明已经向Choreography注册了监听，就不需要再次注册，只需要将自己加入到FrameCallback的监听回调行列中就OK了。</div></pre></td></tr></table></figure>
<h4 id="4-Choreographer-postFrameCallback"><a href="#4-Choreographer-postFrameCallback" class="headerlink" title="4.Choreographer.postFrameCallback()"></a>4.Choreographer.postFrameCallback()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">postFrameCallback--&gt;postCallbackDelayedInternal--&gt;scheduleFrameLocked--&gt;scheduleVsyncLocked--&gt;mDisplayEventReceiver.scheduleVsync--&gt;nativeScheduleVsync</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></div><div class="line">        <span class="keyword">implements</span> <span class="title">Runnable</span> &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</div><div class="line">        mTimestampNanos = timestampNanos;</div><div class="line">        mFrame = frame;</div><div class="line">        Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        mHavePendingVsync = <span class="keyword">false</span>;</div><div class="line">        doFrame(mTimestampNanos, mFrame);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    mFrameInfo.markAnimationsStart();</div><div class="line">    doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</div><div class="line">    ...</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</div><div class="line">        ...</div><div class="line">        c.run(frameTimeNanos);</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"> 在AnimationHanlder调用Choreography.postFrameCallback的时候，FrameCallback封装成CallbackRecord，</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRecord</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> CallbackRecord next;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> dueTime;</div><div class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></div><div class="line">    <span class="keyword">public</span> Object token;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</div><div class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ((Runnable)action).run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-AnimationHandler-mFrameCallback"><a href="#5-AnimationHandler-mFrameCallback" class="headerlink" title="5. AnimationHandler.mFrameCallback"></a>5. AnimationHandler.mFrameCallback</h4><p>4步骤中，此刻token == FRAME_CALLBACK_TOKEN，执行if中的动作，调用的就是AnimationHandler中定义的Choreographer.FrameCallback：上面已经说过，但是上述中省略了最重要的一步：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">        doAnimationFrame(getProvider().getFrameTime());</div><div class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            getProvider().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = mAnimationCallbacks.size();</div><div class="line">    <span class="keyword">long</span> currentTime = SystemClock.uptimeMillis();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">final</span> AnimationFrameCallback callback = mAnimationCallbacks.get(i);</div><div class="line">        <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isCallbackDue(callback, currentTime)) &#123;</div><div class="line">            callback.doAnimationFrame(frameTime);</div><div class="line">            <span class="keyword">if</span> (mCommitCallbacks.contains(callback)) &#123;</div><div class="line">                getProvider().postCommitCallback(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        commitAnimationFrame(callback, getProvider().getFrameTime());</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cleanUpList();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="6-ValueAnimator-doAnimationFrame"><a href="#6-ValueAnimator-doAnimationFrame" class="headerlink" title="6. ValueAnimator.doAnimationFrame"></a>6. ValueAnimator.doAnimationFrame</h4><p>5步骤中callback为AnimationFrameCallback，ValueAnimator实现此接口，因此是调用的ValueAnimator中的doAnimationFrame：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</div><div class="line">    <span class="keyword">boolean</span> finished = animateBasedOnTime(currentTime);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (finished) &#123;</div><div class="line">        endAnimation();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">animateBasedOnTime</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (mRunning) &#123;</div><div class="line">        ...</div><div class="line">        mOverallFraction = clampFraction(fraction);</div><div class="line">        <span class="keyword">float</span> currentIterationFraction = getCurrentIterationFraction(mOverallFraction);</div><div class="line">        animateValue(currentIterationFraction);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> done;</div><div class="line">&#125;</div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object target = getTarget();</div><div class="line">    <span class="keyword">if</span> (mTarget != <span class="keyword">null</span> &amp;&amp; target == <span class="keyword">null</span>) &#123;</div><div class="line">        cancel();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.animateValue(fraction);</div><div class="line">    <span class="keyword">int</span> numValues = mValues.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</div><div class="line">        mValues[i].setAnimatedValue(target);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">super</span>:ValueAnimator.animateValue:</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</div><div class="line">    fraction = mInterpolator.getInterpolation(fraction);</div><div class="line">    mCurrentFraction = fraction;</div><div class="line">    <span class="keyword">int</span> numValues = mValues.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</div><div class="line">        mValues[i].calculateValue(fraction);<span class="comment">//Evalutor就是在这一步完成数值目标转换的</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> numListeners = mUpdateListeners.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">            mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">mValues为之前存放value值的PropertyValueHolder，由value的类型，又划分出FloatValuesHolder，IntValuesHolder，MultiFloatValuesHolder等等，在holder中计算当前的value值，然后调用Object对应的方法，更新属性：</div><div class="line">例如FloatValuesHolder：</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">   ...</div><div class="line">    <span class="keyword">if</span> (mJniSetter != <span class="number">0</span>) &#123;</div><div class="line">        nCallFloatMethod(target, mJniSetter, mFloatAnimatedValue);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mTmpValueArray[<span class="number">0</span>] = mFloatAnimatedValue;</div><div class="line">            mSetter.invoke(target, mTmpValueArray);</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="7-循环流程，直到timeout"><a href="#7-循环流程，直到timeout" class="headerlink" title="7.循环流程，直到timeout"></a>7.循环流程，直到timeout</h4><p>以上步骤为一个动画在一帧中的完整流程，只要动画尚未完成，Animator就不会将自己从AnimationHandler中的监听List中删除，则Choreography.FrameCallback就会持续的注册，监听回调完成后续帧中动画变化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">AnimationHandler:</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">        doAnimationFrame(getProvider().getFrameTime());</div><div class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            getProvider().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ValueAnimator:</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endAnimation</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mAnimationEndRequested) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    AnimationHandler handler = AnimationHandler.getInstance();</div><div class="line">    handler.removeCallback(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    mAnimationEndRequested = <span class="keyword">true</span>;</div><div class="line">    mPaused = <span class="keyword">false</span>;</div><div class="line">    ...</div><div class="line">    mRunning = <span class="keyword">false</span>;</div><div class="line">    mStarted = <span class="keyword">false</span>;</div><div class="line">    mStartListenersCalled = <span class="keyword">false</span>;</div><div class="line">    mReversing = <span class="keyword">false</span>;</div><div class="line">    mLastFrameTime = <span class="number">0</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-小结："><a href="#3-小结：" class="headerlink" title="3, 小结："></a>3, 小结：</h3><ol>
<li>使用多个Animator，AnimatorSet，或者PropertyValueHolder在性能上并没有明显的差异，他们之间的关系大体如下所示：<br><img src="/2017/08/27/Android动画实现原理浅析/single_multi_anim.png" alt="多个Animator的关系"></li>
</ol>
<p>注意到：总体调用对象的次数没有发生变化。</p>
<ol>
<li>如果多个Animator都是操作同一个View的UI属性，则在每一个PropertyValueHolder每次被更新并调用View对应的方法时，就会多次调用view.invalidate和requestlayout方法。这样就会执行很多次非必要的方法，这是就可以考虑使用ViewPropertyAnimator：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">textview.animate().x(<span class="number">500</span>).y(<span class="number">500</span>).setDuration(<span class="number">5000</span>).setInterpolator(<span class="keyword">new</span> BounceInterpolator());</div><div class="line">ViewPropertyAnimator不能直接创建实例对象，只能通过view.animate()来获得针对此View的实例。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>通过查看ViewPropertyAnimator的实现，其实在其内部也是使用的ValueAnimator来实现的view的动画效果，但是呢，ViewPropertyAnimator针对多个Animator调用时的缺点，进行了优化，以提高性能（将需要使用动画的属性，放到一个Map里面，等待下一次的帧更新动作，然后在帧更新时，使用View内部存储的RenderNode节点，将各个属性值设置上去，然后调用View.invalidateViewProperty()(简化版的invalidate操作)）；</p>
<blockquote>
<p>此处可结合在搜狗浏览器V4.5优化网页加载进度条动画效果在天猫等个别重定向甚多的网站时，由于错误的使用ValueAnimator造成invalidate，requestlayout调用次数太多，从而影响了MainHandler其他message的及时响应，造成ANR的问题。。。</p>
</blockquote>
<p>但是使用中应该注意，ViewPropertyAnimator不能在外部持有其实例，以便以后反复使用，必须每次通过View.animate来获得实例。</p>
<ol>
<li>接下来就要分析一下在支持硬件加速的机器上，针对动画开启硬件加速的一些功能。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lyhighfly.github.io/2017/08/20/RxJava应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lyhighfly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myself.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="低级Debuger">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/RxJava应用/" itemprop="url">RxJava应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-20T15:24:51+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TODO-如果发生异常，OnError，Action1运行的线程所在？？？？"><a href="#TODO-如果发生异常，OnError，Action1运行的线程所在？？？？" class="headerlink" title="TODO 如果发生异常，OnError，Action1运行的线程所在？？？？"></a>TODO 如果发生异常，OnError，Action1<throwable>运行的线程所在？？？？</throwable></h1><h1 id="TODO-map-和-flatMap-的原理"><a href="#TODO-map-和-flatMap-的原理" class="headerlink" title="TODO map 和 flatMap 的原理"></a>TODO map 和 flatMap 的原理</h1><h1 id="TODO-与Retrofit的结合使用"><a href="#TODO-与Retrofit的结合使用" class="headerlink" title="TODO 与Retrofit的结合使用"></a>TODO 与Retrofit的结合使用</h1><h1 id="TODO-RxBinding，RxLifeCycle的应用"><a href="#TODO-RxBinding，RxLifeCycle的应用" class="headerlink" title="TODO RxBinding，RxLifeCycle的应用"></a>TODO RxBinding，RxLifeCycle的应用</h1><h2 id="什么是响应式-Reactive"><a href="#什么是响应式-Reactive" class="headerlink" title="什么是响应式(Reactive):"></a>什么是响应式(Reactive):</h2><p>应用开发中的例子：<br>搜索输入框，根据用户实时输入的数据，输入框下方会根据当前输入内容，实时刷新推荐信息，这种就叫做Reactive的能力。<br>类似这种能自动对外部环境的变化做出响应的系统，我们就称之为响应式系统(Reactive System)，其中的外部环境，可以是输入信号的变化，事件的发生等等。通常这个响应式系统不但能响应外部环境的变化，还会根据自身内部状态通过某种方式反馈给外部观察者(推荐内容变化)。</p>
<h2 id="什么是函数式编程-Functional-Programming"><a href="#什么是函数式编程-Functional-Programming" class="headerlink" title="什么是函数式编程(Functional Programming):"></a>什么是函数式编程(Functional Programming):</h2><p> <a href="https://www.zhihu.com/question/28292740" target="_blank" rel="external">函数式编程介绍</a><br> <a href="http://www.infoq.com/cn/articles/functional-reactive-programming?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="external">介绍Callback形式和响应式区别</a><br> <a href="http://www.devtf.cn/?p=323" target="_blank" rel="external">一篇不错的Java响应式导读</a><br> <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">初级入门篇</a></p>
<p>有别于命令式编程，逻辑式编程的一种编程范式，是一种面向数学的抽象，将计算描述为一种表达式求值，而这个表达式就是函数，求值的过程称之为自变量的映射。也就是说一个函数的求值结果，仅取决于自变量和函数本身，不依赖其他状态变量(也就是闭包), 也不修改其他外部变量，没有副作用。自变量可以是常规的变量，也可以是另一个函数(高阶函数)。(当然还有一些其他属性和特征，不详细介绍了)</p>
<h2 id="什么是响应式编程-Reactive-Programming-："><a href="#什么是响应式编程-Reactive-Programming-：" class="headerlink" title="什么是响应式编程(Reactive Programming)："></a>什么是响应式编程(Reactive Programming)：</h2><p>响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p>
<h4 id="函数响应式编程-函数式-响应式-—-gt-函数响应式-Functional-Reactive-Programming"><a href="#函数响应式编程-函数式-响应式-—-gt-函数响应式-Functional-Reactive-Programming" class="headerlink" title="函数响应式编程(函数式+响应式 —&gt; 函数响应式 Functional Reactive Programming)"></a>函数响应式编程(函数式+响应式 —&gt; 函数响应式 Functional Reactive Programming)</h4><p>编程范式关系:</p>
<p><img src="/2017/08/20/RxJava应用/programming-paradigm.png" alt="编程范式关系"></p>
<ul>
<li>利用函数式编程的思想和方法(闭包思想，函数、高阶函数)，来为响应式：事件流，变化传播所用。</li>
</ul>
<h3 id="监听状态变化Callback方式的弊端："><a href="#监听状态变化Callback方式的弊端：" class="headerlink" title="监听状态变化Callback方式的弊端："></a>监听状态变化Callback方式的弊端：</h3><ol>
<li>状态的修改可能分布很多地方，针对状态而作响应动作的地方，也就线性增长；</li>
<li>状态之间可能相互组合，相互影响，不集中管理，有可能出bug，而且很有可能出现未考虑的状态组合；</li>
<li>多重回调，难于调试和跟踪，回调之间关系不清晰；</li>
<li>尤其是在Android中，有UI操作，非UI操作之分，一些必须在UI中，一些一定不能在UI线程中去做。使用Callback难以实现线程的轻松切换</li>
</ol>
<p>而在Java，Android中使用的函数响应式编程框架就是：RxJava，RxAndroid</p>
<p><br><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava的GitHub</a>：函数响应式编程的主框架</p>
<p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid的GitHub</a>：在RxJava基础上针对Android的扩展，用的最多的就是UI线程的切换</p>
<p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html" target="_blank" rel="external">英格力士不好的，可以看看这个翻译文档</a></p>
<h3 id="（1）-什么是RxJava："><a href="#（1）-什么是RxJava：" class="headerlink" title="（1） 什么是RxJava："></a>（1） 什么是RxJava：</h3><blockquote>
<p>摘自GitHub上的一句话介绍：RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.(RxJava 是针对JVM的响应式编程思想的实现，一个使用可观测序列来组成<em>异步</em>和<em>基于事件</em>的library)。</p>
</blockquote>
<p>RxJava的设计思想，就是观察者模式(Observer Pattern)：</p>
<p>Obserable：序列化产生事件的对象；Observer：观察者、订阅者，监听到变化后做出相应的动作。</p>
<p>Obserable和Observer通过subscribe()方法实现订阅(观察，监听)关系，从而在Obserable可以在发生变化的时候通知Observer，并且在完成通知任务之后，又追加了几个方法调用 — error的通知，complete的通知。</p>
<h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"h"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"e"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"l"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"l"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">&#125;&#125;);<span class="comment">//创造一个最基本的事件序列，在被订阅时，依次将预定事件发送给观察者。</span></div><div class="line"></div><div class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer onCompleted"</span>);    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer onError"</span>);    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String o)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer onNext:"</span>+o);    &#125;</div><div class="line">&#125;;</div><div class="line">observable.subscribe(observer);<span class="comment">//发生订阅</span></div></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li><p>只有订阅发生是(observable.subscribe(observer))，事件流才会启动</p>
</li>
<li><p>队列完结是，需要调用onCompleted()，作为事件完结的标志(只有在自定义事件源时才需要这么做)</p>
</li>
<li><p>onComplete和onError是互斥事件</p>
</li>
<li><p>onError()：在事件队列发生异常时，会触发，同时队列自动终止，不允许再有事件发出</p>
</li>
</ol>
<p>以上代码中，Observer定义了一套完整的监听事件，其中包括：每一次事件发生的监听onNext；发射源完成所有发射任务最后的事件：onComplete；如果在事件发射处理过程中有错误发生时：onError。</p>
<p>有时候订阅者(Observer)可能只关心以上三种事件中的几种，也可以定义一个不完整的监听，只定义自己感兴趣的事件，不关心的事件不需要定义。</p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//只对next事件感兴趣：</span></div><div class="line">Observable.just(<span class="string">"hello"</span>, <span class="string">"world"</span>).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer call:"</span>+s);    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//只对next事件或者有可能发生的error感兴趣：</span></div><div class="line">Observable.just(<span class="string">"hello"</span>, <span class="string">"world"</span>).subscribe(</div><div class="line">    <span class="keyword">new</span> Action1&lt;String&gt;() &#123;<span class="comment">//next</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer call:"</span>+s);    &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;<span class="comment">//error</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Oops Error :"</span>+throwable);    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//甚至于对什么都不感兴趣，只是想让被观察者的事件发生：</span></div><div class="line">Observable.just(<span class="string">"hello"</span>, <span class="string">"world"</span>).subscribe();</div></pre></td></tr></table></figure></p>
<p>关于以上几种情况，源代码都有相应的重载方法原型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">()</span>；</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext)</span>；</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext, <span class="keyword">final</span> Action1&lt;Throwable&gt; onError)</span>；</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext, <span class="keyword">final</span> Action1&lt;Throwable&gt; onError, <span class="keyword">final</span> Action0 onCompleted)</span>；</div></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到，从不监听任何事件到监听所有事件，都有方法原型声明。null —&gt;(next) —&gt; (next, error) —&gt; (next, error, complete)；但是不能打破顺序跳跃式监听：例如一下：Obserable.subscribe(new Action1<throwable>) 或者    Obserable.subscribe(new Action0 onCompleted)。而且如果事件队列中途发生错误，而你又没有注册响应的监听事件，就会抛出异常：OnErrorNotImplementedException。因此，缺省监听，最保险的方式是一定要注册Next事件和Error事件。</throwable></p>
</blockquote>
<h3 id="（2）-RxJava常用操作符介绍：官网所列所有操作符-非常庞大"><a href="#（2）-RxJava常用操作符介绍：官网所列所有操作符-非常庞大" class="headerlink" title="（2） RxJava常用操作符介绍：官网所列所有操作符(非常庞大)"></a>（2） RxJava常用操作符介绍：<a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="external">官网所列所有操作符(非常庞大)</a></h3><h5 id="TODO-常用操作符图文介绍"><a href="#TODO-常用操作符图文介绍" class="headerlink" title="TODO 常用操作符图文介绍"></a>TODO 常用操作符图文介绍</h5><ol>
<li>create</li>
<li>just/from</li>
<li>map</li>
<li>flatMap</li>
<li>timer</li>
<li>interval</li>
<li>range</li>
<li>concat</li>
<li>merge/mergeDelayError</li>
<li>startWith</li>
<li>zip</li>
<li>combineLatest/combineLatestDelayError(结合Reader同步更新书架实例)</li>
<li>filter</li>
<li>take/takeLast/takeLastBuffer/takeFirst</li>
<li>ofType</li>
<li>skip/skipLast</li>
<li>elementAt</li>
<li>distinct</li>
<li>throttleFirst/throttleLast</li>
<li>reduce</li>
<li>collect</li>
<li>count</li>
<li>buffer</li>
<li>toList/toSortedList/toMap</li>
</ol>
<h3 id="（3）-RxJava中的线程切换"><a href="#（3）-RxJava中的线程切换" class="headerlink" title="（3） RxJava中的线程切换"></a>（3） RxJava中的线程切换</h3><p>以上栗子中，没有涉及到线程切换的问题，因此都是按照默认的线程在运行：事件的发出和事件的接收在同一个线程中完成，两者所在线程由订阅动作(subscribe)发生的线程所决定。<br>RxJava的主要优势：1，避免了回调地狱；2，便利的线程切换。<br></p>
<p>因此，接下来就要开始最主要的特征了，事件流中的线程切换：Scheduler</p>
<p>还是上面的打印字符的事件栗子，这次主要关注Obserable和Observer的所处线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"hello word"</span>);</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observable  onCompleted in Thread :"</span>+ Thread.currentThread().getName());</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">final</span> Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer receive onCompleted in Thread :"</span>+ Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String o)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer receive onNext in Thread :"</span>+ Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//方便在开始一个订阅任务发生的开始时刻，添加一些额外的动作，比如开始一个网络请求之前，先显示一个loading的页面等等, 注意，在下面的subscribe代码分析中揭示了，此回调发生在subscribe调用所在的线程，因为要特别注意耗时与否</span></div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">observable</div><div class="line">    .subscribeOn(Schedulers.io()) <span class="comment">//事件发出所在线程</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">//事件接收者所在线程</span></div><div class="line">    .subscribe(observer);</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">输出结果：</div><div class="line">Observable  onCompleted in Thread  :Thread-<span class="number">2141</span></div><div class="line">Observer receive onNext in Thread : main</div><div class="line">Observer receive onCompleted in Thread :main</div></pre></td></tr></table></figure>
<p>可以看到通过在订阅是通过方法：subscribeOn，observeOn指定了事件双方分属的线程。这里，我们主要关注的就是Schedulers(调度器)，RxJava就是通过调度器来指定代码应该运行在什么样的线程中，RxJava中已经内置了几种常用的Scheduler：</p>
<p><img src="/2017/08/20/RxJava应用/scheduler-type.png" alt="调度器类型"></p>
<ul>
<li>AndroidSchedulers.mainThread():RxAndroid依赖库中使用最频繁的方法，指定运行在主线程(UI线程)中;</li>
</ul>
<p>切记不能随意使用不正确的调度器，例如对响应敏感的操作，放在了io线程池中，如果当前io线程池中等待执行的任务较多时，造成该敏感任务无法得到及时响应。将本该放在io的耗时操作，放在了computation线程池中，造成固定size的computation线程池长时间被io操作所占用，无法响应其他事件。</p>
<blockquote>
<p>Questions: The first 3 schedulers are pretty self explanatory; however, I’m a little confused about computation and io.<br>What exactly is “IO-bound work”? Is it used for dealing with streams (java.io) and files (java.nio.files)? Is it used for database queries? Is it used for downloading files or accessing REST APIs?<br>How is computation() different from newThread()? Is it that all computation() calls are on a single (background) thread instead of a new (background) thread each time?<br>Why is it bad to call computation() when doing IO work?<br>Why is it bad to call io() when doing computational work?</p>
<p>Great questions, I think the documentation could do with some more detail.<br>io() is backed by an unbounded thread-pool and is the sort of thing you’d use for non-computationally intensive tasks, that is stuff that doesn’t put much load on the CPU. So yep interaction with the file system, interaction with databases or services on a different host are good examples.<br>computation() is backed by a bounded thread-pool with size equal to the number of available processors. If you tried to schedule cpu intensive work in parallel across more than the available processors (say using newThread()) then you are up for thread creation overhead and context switching overhead as threads vie for a processor and it’s potentially a big performance hit.<br>It’s best to leave computation() for CPU intensive work only otherwise you won’t get good CPU utilization.<br>It’s bad to call io() for computational work for the reason discussed in 2. io() is unbounded and if you schedule a thousand computational tasks on io() in parallel then each of those thousand tasks will each have their own thread and be competing for CPU incurring context switching costs.</p>
</blockquote>
<h4 id="3-1-不包含线程切换的订阅发生逻辑："><a href="#3-1-不包含线程切换的订阅发生逻辑：" class="headerlink" title="(3.1) 不包含线程切换的订阅发生逻辑："></a>(3.1) 不包含线程切换的订阅发生逻辑：</h4><pre><code>在分析订阅者，被订阅者线程切换的逻辑之前，先将没有任何线程切换的原始版本订阅发生过程，撸一遍，在搞明白这个后，就可以循循渐进的搞明白，订阅者，被订阅者分别运行的线程是怎么切换的。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以下代码非完整版本，只保留主干。</span></div><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// new Subscriber so onStart it</span></div><div class="line">        subscriber.onStart();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// allow the hook to intercept and/or decorate,RxJavaHooks是用于hook 各种Observable生命周期行为的工具类，此处将其替换成真实的运行步骤</span></div><div class="line">            <span class="comment">//RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);</span></div><div class="line">            <span class="comment">//return RxJavaHooks.onObservableReturn(subscriber);</span></div><div class="line">            observable.onSubscribe.call(subscriber);①</div><div class="line">            <span class="keyword">return</span> (Subscription)subscriber;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="keyword">if</span> (subscriber.isUnsubscribed()) &#123;</div><div class="line">                <span class="comment">//RxJavaHooks.onError(RxJavaHooks.onObservableError(e));</span></div><div class="line">                observable.onSubscribe.callError(subscriber);<span class="comment">//杜撰的方法调用</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//return Subscriptions.unsubscribed();</span></div><div class="line">            <span class="keyword">return</span> (Subscription)subscriber;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>抛除各种关于Observer，Observable的包装，上述代码就是订阅发生之后，Observable emits items 的步骤，对照如下应用示例，大概就可以撸顺整个订阅发生的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;②</div><div class="line">        subscriber.onNext(<span class="string">"hello word"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;④</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String o)</span> </span>&#123;③</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"> observable.subscribe(observer);</div></pre></td></tr></table></figure></p>
<p>在Observable.onSubscribe的call回调中，参数为Subscriber，而我们定义的类型为Observer，这两者是什么关系呢？</p>
<p>Subscriber是Observer接口的实现类，除了实现Observer接口定义的onNext，onError，onComplete方法之外，提供额外的回调(例如onStart)和取消订阅(unsubscribe(),isUnsubscribed())等方法，<br>如果上述示例中，直接使用了Observer，而不是Subscriber，在底层，是会自动将其包装成Subscriber的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (observer <span class="keyword">instanceof</span> Subscriber) &#123;</div><div class="line">        <span class="keyword">return</span> subscribe((Subscriber&lt;? <span class="keyword">super</span> T&gt;)observer);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (observer == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"observer is null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> ObserverSubscriber&lt;T&gt;(observer));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-2-带线程切换的订阅动作："><a href="#3-2-带线程切换的订阅动作：" class="headerlink" title="(3.2) 带线程切换的订阅动作："></a>(3.2) 带线程切换的订阅动作：</h4><ol>
<li>Observable.subscribeOn():<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obserable</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> requestOn)</span> </span>&#123;</div><div class="line">        <span class="comment">//TODO ScalarSynchronousObservable是什么？？？</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">            <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//因为OperatorSubscribeOn 实现了OnSubscribe接口，所以在原Observable被订阅，开始发射事件时，调用的就是OperatorSubscribeOn.call();</span></div><div class="line">        <span class="keyword">return</span> unsafeCreate(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, requestOn));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">unsafeCreate</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">unsafeSubscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ......</div><div class="line">            RxJavaHooks.onObservableStart(<span class="keyword">this</span>, onSubscribe).call(subscriber);</div><div class="line">            <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            ......</div><div class="line">            subscriber.onError(RxJavaHooks.onObservableError(e));</div><div class="line">            ......</div><div class="line">            <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Scheduler scheduler;</div><div class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> requestOn;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler, <span class="keyword">boolean</span> requestOn)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">        <span class="keyword">this</span>.requestOn = requestOn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Worker inner = scheduler.createWorker();</div><div class="line"></div><div class="line">        SubscribeOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnSubscriber&lt;T&gt;(subscriber, requestOn, inner, source);</div><div class="line">        <span class="comment">//便于订阅事件的跟踪，取消等。可暂时不考虑逻辑</span></div><div class="line">        subscriber.add(parent);</div><div class="line">        subscriber.add(inner);</div><div class="line"></div><div class="line">        <span class="comment">//根据Schedulers产生不同的线程切换动作</span></div><div class="line">        inner.schedule(parent);</div><div class="line">        ++++++++++++++++++++++++++++++++++</div><div class="line">            摘选一个Schedulers.newThread()的具体实现来看一下调用逻辑：CachedThreadSchedluer</div><div class="line">            ......</div><div class="line">            ......</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(Action0 action)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> schedule(action, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">public</span> ScheduledAction <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit,  CompositeSubscription parent)</span> </span>&#123;</div><div class="line">                Action0 decoratedAction = RxJavaHooks.onScheduledAction(action);</div><div class="line">                <span class="comment">//对Action0的包装，在executor执行线程时，调用Action0的call方法</span></div><div class="line">                ScheduledAction run = <span class="keyword">new</span> ScheduledAction(decoratedAction, parent);</div><div class="line">                parent.add(run);</div><div class="line">                Future&lt;?&gt; f;</div><div class="line">                <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//实际调用为SubscribeOnSubscriber.call()，此时已经完成线程切换</span></div><div class="line">                    f = executor.submit(run);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    f = executor.schedule(run, delayTime, unit);</div><div class="line">                &#125;</div><div class="line">                run.add(f);</div><div class="line"></div><div class="line">                <span class="keyword">return</span> run;</div><div class="line">            &#125;</div><div class="line">            ......</div><div class="line">            ......</div><div class="line">        </div><div class="line">   </div><div class="line"></div><div class="line">            <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledAction</span> <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Thread</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Subscription</span> </span>&#123;</div><div class="line">                <span class="keyword">final</span> SubscriptionList cancel;</div><div class="line">                <span class="keyword">final</span> Action0 action;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="title">ScheduledAction</span><span class="params">(Action0 action, SubscriptionList parent)</span> </span>&#123;</div><div class="line">                    <span class="keyword">this</span>.action = action;</div><div class="line">                    <span class="keyword">this</span>.cancel = <span class="keyword">new</span> SubscriptionList(<span class="keyword">new</span> Remover2(<span class="keyword">this</span>, parent));</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            ...</div><div class="line">                            ...</div><div class="line">                            action.call();</div><div class="line">                        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                            ...</div><div class="line">                            ...</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            unsubscribe();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        ++++++++++++++++++++++++++++++++++</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeOnSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; actual;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> requestOn;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Worker worker;</div><div class="line"></div><div class="line">        Observable&lt;T&gt; source;</div><div class="line"></div><div class="line">        Thread t;</div><div class="line"></div><div class="line">        SubscribeOnSubscriber(Subscriber&lt;? <span class="keyword">super</span> T&gt; actual, <span class="keyword">boolean</span> requestOn, Worker worker, Observable&lt;T&gt; source) &#123;</div><div class="line">            <span class="keyword">this</span>.actual = actual;</div><div class="line">            <span class="keyword">this</span>.requestOn = requestOn;</div><div class="line">            <span class="keyword">this</span>.worker = worker;</div><div class="line">            <span class="keyword">this</span>.source = source;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">            actual.onNext(t);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                actual.onError(e);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                worker.unsubscribe();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                actual.onCompleted();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                worker.unsubscribe();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//inner.schedule(parent)切换之后的回调方法</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;<span class="comment">//注意：此时已经切换为Worker指定的线程了</span></div><div class="line">            Observable&lt;T&gt; src = source;</div><div class="line">            source = <span class="keyword">null</span>;</div><div class="line">            t = Thread.currentThread();</div><div class="line">            <span class="comment">//原Observable将items发射给当前这个Subscriber(SubscribeOnSubscriber),然后actual(Subscriber)再去将事件进行下一步的分发。</span></div><div class="line">            src.unsafeSubscribe(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        。。。。。。</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">如同上述例子中的Observable.create(OnSubscribe), unsafeCreate方法有产生了一个Observable,并且订阅的新事件为OnSubscribe( = OperatorSubscribeOn)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>至此，调用链为：</p>
<ol>
<li>Observable.create():创建了Observable-1和OnSubscribe-1；</li>
<li>subscribeOn():创建了Observable-2和OperatorSubscribeOn(OnSubscribe-2)，同时，OnSubscribe-2中保存了Observable-1的引用。</li>
<li>Obserable-2.subscribe(Observer):调用了OnSubscribe-2的call方法，在call方法中，通过Schedulers发生了线程切换，线程完成切换之后，调用了Observale-1.unsafeSubscribe(Obserable-2内部实现Subscriber)，此时OnSubscribe-1的call方法被调用，并且发生在Obsubscribe-2.SubscribeOnSubscriber.call所在的线程，此时就完成了源Observable.OnSubscribe发射事件的线程切换。</li>
</ol>
<p>如果多个subscribeOn链接，那么此时，Obserable.OnSubscribe究竟发生在哪个线程呢？？？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"ss"</span>) </div><div class="line">            .subscribeOn(Schedulers.io())   <span class="comment">// --thread-1---</span></div><div class="line">            .subscribeOn(Schedulers.newThread()) <span class="comment">//--thread-2----</span></div><div class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div></pre></td></tr></table></figure>
<p>下面来分析一下这个例子中的线程切换流程：</p>
<pre><code>1，Obserable.just() : 产生Observable-1, OnSubscribe-1

2,Observable-1.subscribeOn(Schedulers.io()) : 产生了Obserable-2, OperatorSubscribeOn-2，并在OperatorSubscribeOn-2中保存了Obserable-1的引用。

3，了Obserable-2..subscribeOn(Schedulers.newThread())：创建Observable-3, OperatorSubscribeOn-3并在OperatorSubscribeOn-3保存Observable-2的引用。

4，Obserable-3.subscribe():
    调用OperatorSubscribeOn_3.call(),改变线程为Schedulers.newThread()。
    调用OperatorSubscribeOn_2.call(),改变线程为Schedulers.io()。
    调用OnSubscribe_1.call(),此时call()运行在Schedulers.io()。
</code></pre><p>根据以上逻辑分析，会按照thread-1的线程进行执行。</p>
<blockquote>
<p>总结：subscribeOn的调用，会改变调用前事件运行的线程，多次调用subscribeOn，只有头部的subscribeOn起作用。<br><img src="/2017/08/20/RxJava应用/rxjava-subsribeon.png" alt="RxJava.subscribeOn线程切换逻辑"></p>
</blockquote>
<ol>
<li>Observable.observeOn():</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">示例：</div><div class="line"></div><div class="line">Observable.just(<span class="string">"ss"</span>) </div><div class="line">    .observeOn(Schedulers.io())</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>接下开始分析observeOn<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obserable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">            <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//首先介绍一下一个关键的操作符，作为事件流转换的基石，由此可以延伸出好多功能的操作符</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> unsafeCreate(<span class="keyword">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeLift</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> OnSubscribe&lt;T&gt; parent;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeLift</span><span class="params">(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">        <span class="keyword">this</span>.operator = operator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Subscriber&lt;? <span class="keyword">super</span> T&gt; st = operator.call(o);</div><div class="line">            ...</div><div class="line">            st.onStart();</div><div class="line">            parent.call(st);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">           ...</div><div class="line">           ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//懒得自己写了，摘抄一段别人的吧</span></div><div class="line">    <span class="comment">/**它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现竟然看起来和前面讲过的 Observable.subscribe() 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 onSubscribe.call(subscriber) 中的 onSubscribe 所指代的对象不同</span></div><div class="line"></div><div class="line">    //subscribe() 中这句话的 onSubscribe 指的是 Observable 中的 onSubscribe 对象，这个没有问题，但是 lift() 之后的情况就复杂了点。</div><div class="line">    //当含有 lift() 时： </div><div class="line">    1. lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了； </div><div class="line">    2. 而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe； </div><div class="line">    3. 当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe； </div><div class="line">    4. 而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。 </div><div class="line">    这样就实现了 lift() 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。</div><div class="line">    精简掉细节的话，也可以这么说：在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。</div><div class="line">**/</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Operator</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class="line">        parent.init();</div><div class="line">        <span class="keyword">return</span> parent;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">         <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">            Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = child;</div><div class="line"></div><div class="line">            localChild.setProducer(<span class="keyword">new</span> Producer() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (n &gt; <span class="number">0L</span>) &#123;</div><div class="line">                        BackpressureUtils.getAndAddRequest(requested, n);</div><div class="line">                        schedule();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;);</div><div class="line">            localChild.add(recursiveScheduler);</div><div class="line">            localChild.add(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            schedule();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            finished = <span class="keyword">true</span>;</div><div class="line">            schedule();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable e)</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            finished = <span class="keyword">true</span>;</div><div class="line">            schedule();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;</div><div class="line">                recursiveScheduler.schedule(<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// only execute this from schedule()</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> Queue&lt;Object&gt; q = <span class="keyword">this</span>.queue;</div><div class="line">            <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = <span class="keyword">this</span>.child;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">long</span> requestAmount = requested.get();</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (requestAmount != currentEmission) &#123;</div><div class="line">                    <span class="keyword">boolean</span> done = finished;</div><div class="line">                    Object v = q.poll();</div><div class="line">                    <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (checkTerminated(done, empty, localChild, q)) &#123;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (empty) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    localChild.onNext(NotificationLite.&lt;T&gt;getValue(v));</div><div class="line"></div><div class="line">                    ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//完成或者异常时的退出</span></div><div class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">checkTerminated</span><span class="params">(<span class="keyword">boolean</span> done, <span class="keyword">boolean</span> isEmpty, Subscriber&lt;? <span class="keyword">super</span> T&gt; a, Queue&lt;Object&gt; q)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (a.isUnsubscribed()) &#123;</div><div class="line">                q.clear();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (done) &#123;</div><div class="line">            ...</div><div class="line">                Throwable e = error;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">                        a.onError(e);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        a.onCompleted();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    recursiveScheduler.unsubscribe();</div><div class="line">                &#125;</div><div class="line">            ...</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，调用链为：</p>
<ol>
<li>Obserable.create() : 创建了Observable-1 ，OnSubscriber-1;</li>
<li>observeOn : 创建了Obserable-2，OnSubscriber-2(OnSubcribeLift)持有OnSubscriber-1的引用，和一个线程变换动作OperatorObserverOn；</li>
<li><p>subscribe(Subscriber-final) :</p>
<p> ① OperatorObserveOn完成线程切换的准备工作，并持有了最终的Suscriber-final(缓存起来)，并以此构造了一个Obserable-1需要使用的Subscriber-temp;</p>
<p> ② Obserable-1调用call(Subscriber)方法，实际是调用了①中创建的Subscriber-temp，如上，Subsriber-temp中的onNext，onComplete，onError，都没有直接调用真实的Subsriber-final对应的方法回调(废话，这样就相当于倒手传递了一下发射的事件，什么都没有做)，而是使用调度方法schedule，触发线程切换动作。</p>
<p> ③ Subscriber-temp 在线程切换之后，回调call方法中，取出①中缓存的Suscriber-final，调用Subscriber-final的onNext，onComplete，onError。</p>
</li>
</ol>
<blockquote>
<p>subscribeOn() 和 observeOn() 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， subscribeOn() 的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。</p>
</blockquote>
<h4 id="TODO-observeOn的流程图"><a href="#TODO-observeOn的流程图" class="headerlink" title="TODO observeOn的流程图"></a>TODO observeOn的流程图</h4><p>懒得画了。。。</p>
<h4 id="3-3-关于调度器线程切换的实现"><a href="#3-3-关于调度器线程切换的实现" class="headerlink" title="(3.3)关于调度器线程切换的实现"></a>(3.3)关于调度器线程切换的实现</h4><h4 id="3-4-subscribeOn、observeOn"><a href="#3-4-subscribeOn、observeOn" class="headerlink" title="(3.4)subscribeOn、observeOn"></a>(3.4)subscribeOn、observeOn</h4><p>综上，subscribeOn关注的是OnSubscriber，observeOn关注的是subscriber.onNext()。</p>
<p>subcribeOn和observeOn 对比分析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable</div><div class="line">.map                    <span class="comment">// 操作1</span></div><div class="line">.flatMap                <span class="comment">// 操作2</span></div><div class="line">.subscribeOn(io)</div><div class="line">.map                    <span class="comment">//操作3</span></div><div class="line">.flatMap                <span class="comment">//操作4</span></div><div class="line">.observeOn(main)</div><div class="line">.map                    <span class="comment">//操作5</span></div><div class="line">.flatMap                <span class="comment">//操作6</span></div><div class="line">.subscribeOn(io)        <span class="comment">//!!特别注意</span></div><div class="line">.subscribe(handleData)</div></pre></td></tr></table></figure></p>
<p>有如上逻辑，则我们对其运行进行分析。</p>
<p>首先，我们需要先明白其内部执行的逻辑。</p>
<p>在调用subscribe之后，逻辑开始运行。分别调用每一步OnSubscribe.call()，注意：自下往上。当运行到最上，即Observable.create()后，我们在其中调用了subscriber.onNext(),于是程序开始自上往下执行每一个对象的subscriber.onNext()方法。最终，直到subscribe()中的回调。</p>
<p>其次，从上面对subscribeOn()和observeOn()的分析中可以明白，subscribeOn()是在call()方法中起作用，而observeOn()是在onNext()中作用。</p>
<p>那么对于以上的逻辑，我们可以得出如下结论：</p>
<p>操作1,2,3,4在io线程中，因为在如果没有observeOn()影响，他们的回调操作默认在订阅的线程中。而我们的订阅线程在subscribeOn(io)发生了改变。注意他们执行的先后顺序。<br>操作5,6在main线程中运行。因为observeOn()改变了onNext().<br>特别注意那一个逻辑没起到作用<br>再简单点总结就是</p>
<p>subscribeOn的调用切换之前的线程。<br>observeOn的调用切换之后的线程。<br>observeOn之后，不可再调用subscribeOn 切换线程<br>复杂情况</p>
<p>我们经常多次使用subscribeOn切换线程，那么以后是否可以组合observeOn和subscribeOn达到自由切换的目的呢？</p>
<p>组合是可以的，但是他们的执行顺序是有条件的，如果仔细分析的话，可以知道observeOn调用之后，再调用subscribeOn是无效的，原因是什么？</p>
<p>因为subscribeOn改变的是subscribe这句调用所在的线程，大多数情况，产生内容和消费内容是在同一线程的，所以改变了产生内容所在的线程，就改变了消费内容所在的线程。</p>
<p>经过上面的阐述，我们知道，observeOn的工作原理是把消费结果先缓存，再切换到新线程上让原始消费者消费，它和生产者是没有一点关系的，就算subscribeOn调用了，也只是改变observeOn这个消费者所在的线程，和OperatorObserveOn中存储的原始消费者一点关系都没有，它还是由observeOn控制。</p>
<p>下面提到的“操作”包括产生事件、用操作符操作事件以及最终的通过 subscriber 消费事件；</p>
<ol>
<li>只有第一subscribeOn() 起作用（所以多个 subscribeOn() 无意义；</li>
<li>这个 subscribeOn() 控制从流程开始的第一个操作，直到遇到第一个 observeOn()；</li>
<li>observeOn() 可以使用多次，每个 observeOn() 将导致一次线程切换()，这次切换开始于这次 observeOn() 的下一个操作；<br>不论是 subscribeOn() 还是 observeOn()，每次线程切换如果不受到下一个 observeOn() 的干预，线程将不再改变，不会自动切换到其他线程。</li>
</ol>
<h3 id="3-发生错误时的逻辑处理"><a href="#3-发生错误时的逻辑处理" class="headerlink" title="3. 发生错误时的逻辑处理"></a>3. 发生错误时的逻辑处理</h3><p>略</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lyhighfly.github.io/2017/04/03/Android-App冷启动优化的一些经验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lyhighfly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myself.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="低级Debuger">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/03/Android-App冷启动优化的一些经验/" itemprop="url">Android App冷启动优化的一些经验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-03T21:30:57+08:00">
                2017-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;关于Android App的优化，百度，Google已经收录了不计其数的文章。常规套路我相信大家基本上应该都可以如数家珍了吧。尤其是国内的技术环境，大众化的，易于理解和实践的优化方式和方法，被粘贴过来，复制过去。无非也就是使用系统提供的工具，例如Traceview, Hierarchyviewer，DDMS，MAT等等，去分析方法的调用，View的层级，内存的占用和一些其他的影响App性能表现的Key。随便查阅四五篇，也就了然于胸了。相比而言，Google搜到的外文技术文章，还有一些App优化的独到见解和处理方式方法，这个会在下文中有所提及。<br>&emsp;&emsp;所以呢，常规套路在这里我就不准备写了，由于最近半年断断续续的都在做Sogou浏览器的冷启动优化，就分享一下在浏览器冷启动优化过程中的一些经验和一些接下来怎么去进一步优化整个App的想法吧。</p>
<blockquote>
<p>说明：这里所说的冷启动，是指非第一次安装的冷启动。由于Android 方法数的限制，Google引入了MultiDex，也正是因为安装包内多了几个Dex文件，导致在第一次安装启动的过程中，多个Dex要做合并编译的优化处理，所以在Sogou浏览器引入的Moudle越来越多的现实状况下，第一次安装启动的时间被拉的越来越长。这一块的优化涉及的技术比较专深，就让负责优化的同事来讲吧。：P </p>
</blockquote>
<h3 id="Sogou浏览器的冷启动优化"><a href="#Sogou浏览器的冷启动优化" class="headerlink" title="Sogou浏览器的冷启动优化"></a>Sogou浏览器的冷启动优化</h3><p>&emsp;&emsp;冷启动时间：从用户点击桌面的ICON到，App启动并展示在前台，可以与用户产生交互的这段时间。冷启动的优化，说的直白一些，就是尽量让App启动的时间变短。假如用户从点击icon到App启动耗费的时间都够用户思考人生了，99%的用户会毫不犹豫的卸载掉咱么的应用，用户的留存率会直线下降。<br>&emsp;&emsp;因此，冷启动的优化，贯穿浏览器的迭代中，每一版在不停的添加模块，添加功能的同时，在灰度上线的前夕专门预留时间来做冷启动的优化，以保证功能增加，时间不加长。<br>每一版的首页架构不同，因此优化的方法也不尽相同，尤其是4.x版本到5.x版本的优化方式，更改较大。今天就着重介绍一下从浏览器5.0版之后的一处优化小细节：</p>
<h4 id="0，衡量标准："><a href="#0，衡量标准：" class="headerlink" title="0，衡量标准："></a>0，衡量标准：</h4><blockquote>
<p>衡量冷启动优化的效果，总要有一个标准，QA的同学是通过摄像头采点的方法来获取冷启动的时间信息的。我们则可以通过adb的命令得到接近的效果，虽然完全启动用户可见的时间点可能会较QA的测试有所不同，但是作为纵向对比工具已经足够了。</p>
</blockquote>
<p><img src="http://up.1.sogou.com/files/2016/10/28/627e0dc3401985c603e025bf225be7f3.png" alt="&quot;adb命令&quot;" title="adb命令"></p>
<h5 id="以下摘自其他人的博客："><a href="#以下摘自其他人的博客：" class="headerlink" title="以下摘自其他人的博客："></a>以下摘自其他人的博客：</h5><p>“adb shell am start -W ”的实现在frameworks\base\cmds\am\src\com\android\commands\am\Am.java文件中。其实就是跨Binder调用ActivityManagerService.startActivityAndWait()接口,然后等待返回结果，结束本次启动过程并将统计数据打印出来。（后面将ActivityManagerService简称为AMS），<br><img src="http://up.1.sogou.com/files/2016/10/28/8ccff652ff16a76045ff90f69d36cd8d.png" alt=""><br>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br><img src="http://up.1.sogou.com/files/2016/10/28/260b26499bc64cdbece26ac221b3335f.png" alt=""></p>
<p>result中的thisTime，totalTime时间的计算，是在：frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java中：<br><img src="http://up.1.sogou.com/files/2016/10/28/58ddd5d610c0ce98a7ab0048314f20e5.png" alt=""><br>curTime表示该函数调用的时间点.<br>displayStartTime表示一连串启动Activity中的最后一个Activity的启动时间点.<br>mLaunchStartTime表示一连串启动Activity中第一个Activity的启动时间点.</p>
<p>正常情况下点击桌面图标只启动一个有界面的Activity，此时displayStartTime与mLaunchStartTime便指向同一时间点，此时ThisTime=TotalTime。另一种情况是点击桌面图标应用会先启动一个无界面的Activity做逻辑处理，接着又启动一个有界面的Activity，在这种启动一连串Activity的情况下，displayStartTime便指向最后一个Activity的开始启动时间点，mLaunchStartTime指向第一个无界面Activity的开始启动时间点，此时ThisTime！=TotalTime。这两种情况如下图：<img src="http://up.1.sogou.com/files/2016/10/28/ef7f63177f7a328da72704a35e78a6a9.png" alt="&quot;TotalTime/ThisTime的关系&quot;"><br>在上面的图中，我用①②③分别标注了三个时间段，在这三个时间段内分别干了什么事呢？</p>
<ol>
<li>在第①个时间段内，AMS创建ActivityRecord记录块和选择合理的Task、将当前Resume的Activity进行pause；</li>
<li>在第②个时间段内，启动进程、调用无界面Activity的onCreate()等、pause/finish无界面的Activity；</li>
<li>在第③个时间段内，调用有界面Activity的onCreate、onResume；</li>
</ol>
<p>看到这里应该清楚 ThisTime、TotalTime、WaitTime三个时间的关系了吧。WaitTime就是总的耗时，包括前一个应用Activity pause的时间和新应用启动的时间；ThisTime表示一连串启动Activity的最后一个Activity的启动耗时；TotalTime表示新应用启动的耗时，包括新进程的启动和Activity的启动，但不包括前一个应用Activity pause的耗时。也就是说，开发者一般只要关心TotalTime即可，这个时间才是自己应用真正启动的耗时。</p>
<p>Event log中TAG=am_activity_launch_time中的两个值分表表示ThisTime、TotalTime，跟通过“adb shell am start -W ”得到的值是一致的。</p>
<p>最后再说下系统根据什么来判断应用启动结束。我们知道应用启动包括进程启动、走Activity生命周期onCreate/onResume等。在第一次onResume时添加窗口到WMS(WindowManagerService)中，然后measure/layout/draw，窗口绘制完成后通知WMS，WMS在合适的时机控制界面开始显示(夹杂了界面切换动画逻辑)。记住是窗口界面显示出来后，WMS才调用reportLaunchTimeLocked()通知AMS Activity启动完成。</p>
<h4 id="1，应用层面的分析："><a href="#1，应用层面的分析：" class="headerlink" title="1，应用层面的分析："></a>1，应用层面的分析：</h4><p>当用户点击Launcher的Sogou Icon之后的动作，从一个App开发者角度看，要经历一下过程，才能展示在用户眼前：</p>
<hr>
<p> Launcher Icon  —&gt;  BrowserApp(Sogou Application)  —&gt;  BrowserActivity.onCreate()(Sogou Main Activity)  —&gt;  BrowserActivity.onResume()  —&gt;  showing</p>
<hr>
<p>以上就是搜狗浏览器在启动过程中的必经之路，从BrowserApp开始就是我们可以控制的启动过程了。尽量缩短从Launcher Icon —&gt;  Showing的时间是我们的目的。<br>将BrowserApp和BrowserActivity.onCreate()和BrowserActivity.onResume()非必要代码移到启动过程之后，精简主页面的布局结构，去掉非必要的层级嵌套。之后进行测试，也确实缩短了一些时间，但是不是太明显。再将不必要的层级，不必要的代码减无可减的情况下，启动时间的提升却很有限。我曾经尝试过把主页面的内容全部置空，确实启动时间有了质的提升，遂想先启动开BrowserActivity，然后在BrowserActivity.onResume()之后再去延迟渲染加载真实的主页面，但这样用户体验就会极差，用户会看到短暂的空白页，然后才能看到真实的主页面，优化冷启动速度的目的本是提高加载速度，以便让用户等待最短的时间就可以与APP进行交互。如果主页面延迟显示，不仅没有提升用户体验，反而让用户更能明显的感知到APP缓慢的启动过程，有点顾此失彼，本末倒置。</p>
<h5 id="观察竞品QQ浏览器"><a href="#观察竞品QQ浏览器" class="headerlink" title="观察竞品QQ浏览器:"></a>观察竞品QQ浏览器:</h5><p><img src="http://up.1.sogou.com/files/2016/10/28/2b3176e54a6fd2580e3057b44aa893e1.png" alt=""><br><img src="http://up.1.sogou.com/files/2016/10/28/43ff429382cea8c63ff7b91ff4ed80d3.png" alt=""></p>
<blockquote>
<p>Q浏览器新版的更改较大，稍后再说。但是在较早之前的版本，他们的页面如图所示，也不简单，但是他们能做到秒开，右图为QA提供的当时的测试数据直方图。</p>
</blockquote>
<p>在显示布局边界选项开启，反复启动QQ浏览器，你会发现一些现象：在启动后可见的极短时间内，整个界面的布局边界不会如上图所示，而是就显示了一个View的布局边界。而且，在这段时间内，浏览器是不响应任何事件的。所以，我们大胆的推测，QQ浏览器在启动的过程中，不是按部就班，老老实实的展示真实的页面的，而是先展示了一直图片，然后再使用真实的页面内容将其替换掉。<br>假设完，接下来就是要去求证。在同事通过编译Android ROM，在关键节点打印信息，通过分析，证实了我们的猜测，并且转存了他们截图，并替换成其他图片，QQ浏览器在接下来的启动过程中也确实显示的是我们偷梁换柱的图片。</p>
<h4 id="2，我们怎么做？："><a href="#2，我们怎么做？：" class="headerlink" title="2，我们怎么做？："></a>2，我们怎么做？：</h4><p>&emsp;&emsp;取证、验证完了，证明QQ浏览器就是这么做的，接下来要做的事情就是比着葫芦画瓢了。主页面截图，开机启动展示截图，并替换成真实的页面信息。这些都很easy。但是，关键点在于：截图和真实内容替换的时机，到底在什么时机完成狸猫换太子呢？？？<br>&emsp;&emsp;刚开始的想法：在BrowserActivity.onCreate()的开始，将截图贴上去，然后在BrowserActivity.onResume()通过Handler delay一定时间后再用真实页面去替换掉截图(之所以延时，是因为onResume距离页面可见还有一段时间间隔)。这样做确实是可以的，但是在delay多少时间的确定上就遇到了大麻烦，因为从onResume()到页面展示，中间的时长是和手机性能密切相关的，在高端机上需要0.5s，在低端机上就有可能需要5s，相差很大。我们不可能跟割韭菜一样，齐刷刷的一刀切，这样或许在低端机上对于冷启动速度有所提升，但是在高端机上，就等于人为的拉长加载时间。再说手机的配置，日新月异，整体Android市场的手机配置正在往高端靠拢，咱们不可能为了优化低端机上的表现，把所有高端机的性能拉低。<br>&emsp;&emsp;后来也想过保持delay的方案不变，通过动态的去配置delay的时间来保证高中低端机都有合适的delay时长。但是，仔细想就放弃了，android市场和ios市场不同，市面上的手机，千差万别，配置更是五花八门，我们不可能为所有的手机去指定delay时间，即使按照cpu，内存等参数，去指定粗略的delay时长也是非常耗时，耗人力的，遂放弃。</p>
<p>恰好彼时正在改版首页面的快链模块，由于要做快速链接的大改版，整体的效果跟Android  Launcher差不多，就是可以跨越多个屏幕进行icon的排序，整理，删除等功能。所以就参考了一些系统launcher的源代码，看到在LauncherModel中有许多地方用到MessageQueue中提供的IdleHandler，从字面理解就是空闲处理，源码关于这一块的处理如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</div><div class="line">-     ......</div><div class="line">-</div><div class="line">-     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">-         Looper me = myLooper();</div><div class="line">-         MessageQueue queue = me.mQueue;</div><div class="line">-</div><div class="line">-         ......</div><div class="line">-</div><div class="line">-         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">-             Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">-             ......</div><div class="line">-</div><div class="line">-             <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">-                 <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">-                     <span class="comment">// No target is a magic identifier for the quit message.</span></div><div class="line">-                     <span class="keyword">return</span>;</div><div class="line">-                 &#125;</div><div class="line">-</div><div class="line">-                 ......</div><div class="line">-</div><div class="line">-                 msg.target.dispatchMessage(msg);</div><div class="line">-</div><div class="line">-                 ......</div><div class="line">-</div><div class="line">-                 msg.recycle();</div><div class="line">-             &#125;</div><div class="line">-         &#125;</div><div class="line">-     &#125;</div><div class="line">-</div><div class="line">-     ......</div><div class="line">- &#125;</div></pre></td></tr></table></figure></p>
<p>Looper中是一个死循环，一直从MessageQueue中取Message，然后交给Handler去处理，当没有任何数据可以取得时候，循环会阻塞在MessageQueue.next()方法上，直到有新的数据，在CPP底层，通过Binder去通知上层，解除阻塞，继续循环取Message得操作。<br>而在MessageQueue中提供Message的next()方法内部实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</div><div class="line">-     ......</div><div class="line">-</div><div class="line">-     <span class="function"><span class="keyword">final</span> Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">-         <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">-         <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">-</div><div class="line">-         <span class="keyword">for</span> (;;) &#123;</div><div class="line">-             <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">-                 Binder.flushPendingCommands();</div><div class="line">-             &#125;</div><div class="line">-             nativePollOnce(mPtr, nextPollTimeoutMillis);</div><div class="line">-</div><div class="line">-             <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">-                 <span class="comment">// Try to retrieve the next message.  Return if found.</span></div><div class="line">-                 <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">-                 <span class="keyword">final</span> Message msg = mMessages;</div><div class="line">-                 <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">-                     <span class="keyword">final</span> <span class="keyword">long</span> when = msg.when;</div><div class="line">-                     <span class="keyword">if</span> (now &gt;= when) &#123;</div><div class="line">-                         mBlocked = <span class="keyword">false</span>;</div><div class="line">-                         mMessages = msg.next;</div><div class="line">-                         msg.next = <span class="keyword">null</span>;</div><div class="line">-                         <span class="keyword">if</span> (Config.LOGV) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</div><div class="line">-                         <span class="keyword">return</span> msg;</div><div class="line">-                     &#125; <span class="keyword">else</span> &#123;</div><div class="line">-                         nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(when - now, Integer.MAX_VALUE);</div><div class="line">-                     &#125;</div><div class="line">-                 &#125; <span class="keyword">else</span> &#123;</div><div class="line">-                     nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">-                 &#125;</div><div class="line">-</div><div class="line">-                 <span class="comment">// If first time, then get the number of idlers to run.</span></div><div class="line">-                 <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span>) &#123;</div><div class="line">-                     pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">-                 &#125;</div><div class="line">-                 <span class="keyword">if</span> (pendingIdleHandlerCount == <span class="number">0</span>) &#123;</div><div class="line">-                     <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></div><div class="line">-                     mBlocked = <span class="keyword">true</span>;</div><div class="line">-                     <span class="keyword">continue</span>;</div><div class="line">-                 &#125;</div><div class="line">-</div><div class="line">-                 <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">-                     mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">-                 &#125;</div><div class="line">-                 mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">-             &#125;</div><div class="line">-</div><div class="line">-             <span class="comment">// Run the idle handlers.</span></div><div class="line">-             <span class="comment">// We only ever reach this code block during the first iteration.</span></div><div class="line">-             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">-                 <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">-                 mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line">-</div><div class="line">-                 <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">-                 <span class="keyword">try</span> &#123;</div><div class="line">-                     keep = idler.queueIdle();</div><div class="line">-                 &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">-                     Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">-                 &#125;</div><div class="line">-</div><div class="line">-                 <span class="keyword">if</span> (!keep) &#123;</div><div class="line">-                     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">-                         mIdleHandlers.remove(idler);</div><div class="line">-                     &#125;</div><div class="line">-                 &#125;</div><div class="line">-             &#125;</div><div class="line">-</div><div class="line">-             <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">-             pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line">-</div><div class="line">-             <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">-             <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">-             nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">-         &#125;</div><div class="line">-     &#125;</div><div class="line">-</div><div class="line">-     ......</div><div class="line">- &#125;</div></pre></td></tr></table></figure></p>
<p>该方法在消息队列中没有消息或者消息的执行时间还没有到，都会使其进入线程等待，而在进入等待状态前会去处理mPendingIdleHandlers中的数据，而其中的数据，就是通过MessageQueue.addIdleHandler将其放入到mPendingIdleHandlers中去的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</div><div class="line">-     ......</div><div class="line">-</div><div class="line">-     <span class="comment">/**</span></div><div class="line">-     * Callback interface for discovering when a thread is going to block</div><div class="line">-     * waiting for more messages.</div><div class="line">-     */</div><div class="line">-     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</div><div class="line">-         <span class="comment">/**</span></div><div class="line">-         * Called when the message queue has run out of messages and will now</div><div class="line">-         * wait for more.  Return true to keep your idle handler active, false</div><div class="line">-         * to have it removed.  This may be called if there are still messages</div><div class="line">-         * pending in the queue, but they are all scheduled to be dispatched</div><div class="line">-         * after the current time.</div><div class="line">-         */</div><div class="line">-         <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</div><div class="line">-     &#125;</div><div class="line">-</div><div class="line">-     ......</div><div class="line">- &#125;</div></pre></td></tr></table></figure></p>
<p><strong>ok，整理以上内容：Handler通过轮询去处理MessageQueue中取出的数据，MessageQueue没有数据需要处理时，会进入wait状态，而在进入wait之前，会处理IdleHandler的东西。</strong></p>
<p>我们的想法就是，手机性能各有不同，所以，就让手机去执行该执行的任务，在任务完成，进入wait的时机，把我们的截图替换上去，然后手机还是去执行必要的加载任务(完成View的绘制)，然后在下一个wait到来的时机，再将截图去替换成真是的Views。</p>
<p>上述想法需要一个充分必要条件：App启动过程中的确有使主线程Handler进入wait的时间点，且这个点，到来的比较快，之前不会做太多App自己的动作。应用程序的启动过程比较复杂，且冗长。有兴趣可以看一下：<a href="老罗老师的博客，分析App启动过程">http://blog.csdn.net/luoshengyang/article/details/6747696</a>。这里只截取关键的几个点：</p>
<p>ActivityManagerService 通过调用ApplicationThread中的scheduleLaunchActivity去加载App默认的Activity，而这个scheduleLaunchActivity是在ActivityThread中实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</div><div class="line">-</div><div class="line">-     <span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</div><div class="line"></div><div class="line">-     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">-         ......</div><div class="line">-</div><div class="line">-        Looper.prepareMainLooper();</div><div class="line">-        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">-         thread.attach(<span class="keyword">false</span>);</div><div class="line">-        <span class="keyword">if</span>(sMainThreadHandler == <span class="keyword">null</span>)&#123;</div><div class="line">-              sMainThreadHandler = thread.getHandler();</div><div class="line">-        &#125;</div><div class="line">-         ......</div><div class="line">-     &#125;</div><div class="line"></div><div class="line">-      ......</div><div class="line">-     <span class="function"><span class="keyword">final</span>  Handler <span class="title">getHandler</span><span class="params">()</span></span>&#123;</div><div class="line">-       <span class="keyword">return</span> mH;</div><div class="line">-     &#125;</div><div class="line"></div><div class="line">-     <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;</div><div class="line">-</div><div class="line">-         <span class="comment">// we use token to identify this activity without having to send the</span></div><div class="line">-         <span class="comment">// activity itself back to the activity manager. (matters more with ipc)</span></div><div class="line">-         <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></div><div class="line">-                 ActivityInfo info, Bundle state, List&lt;ResultInfo&gt; pendingResults,</div><div class="line">-                 List&lt;Intent&gt; pendingNewIntents, <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward) &#123;</div><div class="line">-             ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</div><div class="line">-</div><div class="line">-             r.token = token;</div><div class="line">-             r.ident = ident;</div><div class="line">-             r.intent = intent;</div><div class="line">-             r.activityInfo = info;</div><div class="line">-             r.state = state;</div><div class="line">-</div><div class="line">-             r.pendingResults = pendingResults;</div><div class="line">-             r.pendingIntents = pendingNewIntents;</div><div class="line">-</div><div class="line">-             r.startsNotResumed = notResumed;</div><div class="line">-             r.isForward = isForward;</div><div class="line">-</div><div class="line">-             queueOrSendMessage(H.LAUNCH_ACTIVITY, r);</div><div class="line">-         &#125;</div><div class="line"></div><div class="line">-         <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">queueOrSendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</div><div class="line">-             <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">-                 ......</div><div class="line">-                 Message msg = Message.obtain();</div><div class="line">-                 msg.what = what;</div><div class="line">-                 msg.obj = obj;</div><div class="line">-                 msg.arg1 = arg1;</div><div class="line">-                 msg.arg2 = arg2;</div><div class="line">-                 mH.sendMessage(msg);</div><div class="line">-             &#125;</div><div class="line">-         &#125;</div><div class="line">-       <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">-</div><div class="line">-            ......</div><div class="line">-</div><div class="line">-            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">-             ......</div><div class="line">-             <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">-             ......</div><div class="line">-             &#125;</div><div class="line">-</div><div class="line">-            ......</div><div class="line">-</div><div class="line">-     &#125;</div><div class="line">-</div><div class="line">- &#125;</div></pre></td></tr></table></figure></p>
<p>这里首次出现了往主线程的Handler发送信息的queueOrSendMessage，其方法内部将ActivityClientRecord 封装成Message，然后发送给mH这个Handler。而这个mH就是ActivityThread的私有类，应用进程启动之后，就会加载ActivityThread的main方法，这时候就是创建ActivityThread的对象，并在此工程中创建mH的对象，接下来的步骤，比较复杂：<br>一般View往主线程发送Runnable的作法如下：<br><img src="http://up.1.sogou.com/files/2016/10/28/024bd2f96812848a7c6e438006f59a02.png" alt=""><br>那么这个AttachInfo的mHandler就是主线程的Handler，就是上文中提到的mH。</p>
<p>Activity和View的交互，是通过WindowManager来实现的，WindowManager创建PhoneWindow负责View的添加、删除和View的各种其他声明周期方法，而这个WindowManager其实是一个SystemService，其是在Context的具体实现类ContextImpl中创建的：<br><img src="http://up.1.sogou.com/files/2016/10/28/e87da139b8132b4bcd03ab41da8b8324.png" alt=""><br>这样就把ActivityThread创建的MainHandler传递给了WindowManager，然后WindowManager创建PhoneWindow，再然后PhoneView创建DecorView和ViewRootImpl，在再然后往DecorView添加子View的时候，MainHandler就会作为AttachInfo的变量，在View attachToWindow的时候传递给子View(这也就解释了为什么在添加完View就调用View的post方法会失败的原因)。<br>就是ActivityThread执行Application，和Activity的生命周期，其中也会用到这个mH，然后走到Activity的onCreate，然后将App的Layout attach to DecorView，如果Layout本身添加了动画，也会使用到mH。添加Layout之后，如果没有业务逻辑，此时，mH 就马上要进入wait状态了，这就是一个好的时机。</p>
<p>&emsp;&emsp;所以，为了让App主线程的mH尽早的进入wait状态，要尽量保证，在Application生命周期，Activity启动的生命周期的各种回调不做耗时操作，尽量不使用mH去做事情；将Layout尽量简化，去掉不必要的动画。然后在此时，把IdleHandler塞给MessageQueue，让mH有机会去处理。</p>
<h4 id="3，搜狗浏览器的实践："><a href="#3，搜狗浏览器的实践：" class="headerlink" title="3，搜狗浏览器的实践："></a>3，搜狗浏览器的实践：</h4><p>&emsp;&emsp;搜狗浏览器的做法就是：BrowserApp和BrowserActivity.onCreate中，减少或者延时耗时操作。不使用主线程的Handler，将BrowserActivity的根layout，开始时设置为一个空的FrameLayout，并将上一次退出时保存的首页截图mScreenShotImage add 到这个空的FrameLayout中，scaleType = “fitXY”。然后App启动回调到BrowserActivity.onCreate时，先将包含截图的空FrameLayout直接add 到 ViewRoot(id=android.R.id.content的根ViewGroup)。然后再把替换Views 的步骤包装成IdleHandler塞给Hanlder。紧接着在完成Views绘制之后，包装一个去掉截图空FrameLayout的IdleHandler到Handler中，让其执行用来完成图片的替换过程，至此完成整个启动。<br><img src="http://up.1.sogou.com/files/2016/10/28/1fe07e3db0db534b4df56cbde4342bec.png" alt="&quot;贴上一个空FrameLayout的同时，将真实UI初始化方法initUI()放到一个IdleHandler中，等待被主UI的Handler空闲时执行&quot;"></p>
<h5 id="initUI-Bundle-："><a href="#initUI-Bundle-：" class="headerlink" title="initUI(Bundle)："></a>initUI(Bundle)：</h5><p><img src="http://up.1.sogou.com/files/2016/10/28/f2d8859d34d7635998042f3634c809f4.png" alt="&quot;initUI()方法完成的最后，将去掉空FrameLayout的步骤放到一个IdelHandler中，等待被主UI的Handler空闲时执行&quot;"></p>
<h5 id="其中，MainHandler就是主线程的Handler，mBrowserFrameLayout就是那个空架子，mScreenShotImage就是上一次的App-Home页面截图。"><a href="#其中，MainHandler就是主线程的Handler，mBrowserFrameLayout就是那个空架子，mScreenShotImage就是上一次的App-Home页面截图。" class="headerlink" title="其中，MainHandler就是主线程的Handler，mBrowserFrameLayout就是那个空架子，mScreenShotImage就是上一次的App Home页面截图。"></a>其中，MainHandler就是主线程的Handler，mBrowserFrameLayout就是那个空架子，mScreenShotImage就是上一次的App Home页面截图。</h5><h5 id="MainHandler中的waitForIdle实现如下："><a href="#MainHandler中的waitForIdle实现如下：" class="headerlink" title="MainHandler中的waitForIdle实现如下："></a>MainHandler中的waitForIdle实现如下：</h5><p><img src="http://up.1.sogou.com/files/2016/10/28/dda45874fe5975d420851a5ab8daa57a.png" alt=""><br><img src="http://up.1.sogou.com/files/2016/10/28/6ef44346f7024d5157d622f44d1a5539.png" alt=""></p>
<h5 id="Looper-getQueue-会报错是因为我们的应用要兼容低版本Android，而getQueue-这个方法是Api23以上才公开的方法，不过不用担心，因为追溯到Android2-3的手机上，Framework的层Looper实现中都是有getQueue-这个方法的，只是低版本都是private的。"><a href="#Looper-getQueue-会报错是因为我们的应用要兼容低版本Android，而getQueue-这个方法是Api23以上才公开的方法，不过不用担心，因为追溯到Android2-3的手机上，Framework的层Looper实现中都是有getQueue-这个方法的，只是低版本都是private的。" class="headerlink" title="Looper.getQueue()会报错是因为我们的应用要兼容低版本Android，而getQueue()这个方法是Api23以上才公开的方法，不过不用担心，因为追溯到Android2.3的手机上，Framework的层Looper实现中都是有getQueue()这个方法的，只是低版本都是private的。"></a>Looper.getQueue()会报错是因为我们的应用要兼容低版本Android，而getQueue()这个方法是Api23以上才公开的方法，不过不用担心，因为追溯到Android2.3的手机上，Framework的层Looper实现中都是有getQueue()这个方法的，只是低版本都是private的。</h5><p>关于截图的时机，我们现在是在App退出的回调去执行的。</p>
<h4 id="关于横竖屏启动，截图使用可能错误：竖着启动，可能使用上次退出横屏的截图；反之也是类似的情况。对比了QQ浏览器，我们采用了相同的做法，只是用竖屏截图，横屏下退出不截图。然后如果用户横屏启动，要加一点额外的处理："><a href="#关于横竖屏启动，截图使用可能错误：竖着启动，可能使用上次退出横屏的截图；反之也是类似的情况。对比了QQ浏览器，我们采用了相同的做法，只是用竖屏截图，横屏下退出不截图。然后如果用户横屏启动，要加一点额外的处理：" class="headerlink" title="关于横竖屏启动，截图使用可能错误：竖着启动，可能使用上次退出横屏的截图；反之也是类似的情况。对比了QQ浏览器，我们采用了相同的做法，只是用竖屏截图，横屏下退出不截图。然后如果用户横屏启动，要加一点额外的处理："></a>关于横竖屏启动，截图使用可能错误：竖着启动，可能使用上次退出横屏的截图；反之也是类似的情况。对比了QQ浏览器，我们采用了相同的做法，只是用竖屏截图，横屏下退出不截图。然后如果用户横屏启动，要加一点额外的处理：</h4><p><img src="http://up.1.sogou.com/files/2016/10/28/41197bbe6ca78f6dd6fcbcb889776117.png" alt="&quot;横竖屏启动时，使用截图时的处理细节&quot;"></p>
<h4 id="最后，还有一些细枝末节的处理，因为作为浏览器，会比普通App的调用场景更复杂多变一些。"><a href="#最后，还有一些细枝末节的处理，因为作为浏览器，会比普通App的调用场景更复杂多变一些。" class="headerlink" title="最后，还有一些细枝末节的处理，因为作为浏览器，会比普通App的调用场景更复杂多变一些。"></a>最后，还有一些细枝末节的处理，因为作为浏览器，会比普通App的调用场景更复杂多变一些。</h4><h4 id="最终结果还是比较令人满意的：Duang"><a href="#最终结果还是比较令人满意的：Duang" class="headerlink" title="最终结果还是比较令人满意的：Duang~~~"></a>最终结果还是比较令人满意的：Duang~~~</h4><p><img src="http://up.1.sogou.com/files/2016/10/28/44cce1e038a1f6f5325d634a3d539c3a.png" alt="&quot;冷启动优化测试直方图&quot;"></p>
<p>先就这么多吧。：P</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/myself.jpg"
               alt="lyhighfly" />
          <p class="site-author-name" itemprop="name">lyhighfly</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives">
            
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lyhighfly</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">
      
    </span>
  
  &nbsp;&nbsp;|&nbsp;&nbsp;本站总点击 <span id="busuanzi_value_site_pv"></span> 次
  &nbsp;&nbsp;|&nbsp;&nbsp;您是第 <span id="busuanzi_value_site_uv"></span> 位访客

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  








  








  





  

  

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.2"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.2"></script>


  

  <script type="text/javascript" src="/js/src/baidu-auto-push.js"></script>
</body>
</html>
