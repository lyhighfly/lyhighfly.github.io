<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="低级Debuger">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="低级Debuger">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="低级Debuger">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>低级Debuger</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">低级Debuger</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">是个懒蛋</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/27/Android动画实现原理浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lyhighfly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myself.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="低级Debuger">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/Android动画实现原理浅析/" itemprop="url">Android动画实现原理浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-27T15:24:51+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android中的动画使用注意事项"><a href="#Android中的动画使用注意事项" class="headerlink" title="Android中的动画使用注意事项"></a>Android中的动画使用注意事项</h2><p>基本上现如今市面上所有的app，都会使用到动画效果，动画可以很好的提升用户的交互体验。</p>
<p>Android中的动画大概可以分成两个发展阶段：在Android3.0之前，Framework层提供了android.view.animation，可以实现View，ViewGroup的各种动画效果，比如AlphaAnimation，RotateAnimation，ScaleAnimation，TranslateAnimation，就可以分别实现透明度，旋转，缩放，位移等动画效果。当然，也可以通过AnimationSet将多个动画联合使用，以达到更复杂的效果。</p>
<p>为什么在Android3.0之后，就不推荐使用animation的动画了呢，是因为它大概有以下几点缺点：</p>
<ol>
<li>animation的动画，只能实现View的简单的动画效果，负责的，比如颜色过渡无法实现；</li>
<li>animation只能操作View及其子类的可视化动画效果，但是，有可能一些非view类型的动画效果无法实现；</li>
<li>animation只是简单的将view的视图信息发生了改变以达到视觉上的动画效果，但是view自身的属性没有发生根本的变化。</li>
</ol>
<p>为了弥补以上的缺点和不足，在Android3.0以上，Framework又提供了另一套动画框架：android.animation.animator。</p>
<blockquote>
<ol>
<li>Animation在动画实现的机制上与Animation是完全不同的。一句话概括就是：Animation实在每次绘制之前，通过将整块画布矩阵变换，从而实现视觉坐标系的移动、变换，但实际上其view内部记录的坐标信息以及其他属性始终没有发生变化。</li>
<li>Animator其实在动画实现上更加直接，简单一些。他是计算动画节点上对应的value，然后将此value通过不同的方式作用到view的属性参数上。（以下会有更详细的Animator机制的介绍）</li>
</ol>
</blockquote>
<p>两者的优劣对比：</p>
<ol>
<li>版本兼容性：Animation全版本支持。Animator只能支持Android3.0以上。</li>
<li>使用范围：Animation只能操作view。Animator不仅支持view动画，还可以操作多种属性的变化，任何实现相关方法的对象，都可以使用Animator来达到属性变化的过程。</li>
<li>实现效率：Animation通过画布矩阵变换处理view的动画效果。Animator则是通过对象属性set，get方法的反射调用，来达到所操作对象相关属性的变化的。因此，从效率上来说，Animation的效率可能稍高一些，而Animator由于在动画过程中要使用反射，效率稍差一些。</li>
<li>使用效果：Animation因为只是画布的矩阵变化，view的属性，位置信息并没有发生变化，所以，动画之后view的点击事件等处理都会非常麻烦。Animator因为是直接操作view的属性，在做动画的同时，view的属性也相应的发生了变化，所以不用担心view的属性与视觉上不一致的问题。</li>
</ol>
<blockquote>
<p>随着Android系统版本不断的提升，使用3.0以下系统的手机将会越来越少，时间效率。所以也就没有必要单独去深入源码分析Animation的实现原理了。而Animator是高版本一直支持的框架，因此，着重分析一下在可预见的很长一段时间内Android一直会使用的Animator的实现原理吧。</p>
</blockquote>
<h3 id="1，继承关系"><a href="#1，继承关系" class="headerlink" title="1，继承关系"></a>1，继承关系</h3><p><img src="/2017/08/27/Android动画实现原理浅析/animatorimpl.png" alt="Animator类层级"></p>
<h3 id="2-Animator的工作流程"><a href="#2-Animator的工作流程" class="headerlink" title="2, Animator的工作流程"></a>2, Animator的工作流程</h3><p><img src="/2017/08/27/Android动画实现原理浅析/anim_timeline.png" alt="Animator类层级"></p>
<h4 id="1，ObjectAnimator-ofXXX-Object-target-String-propertyName-TYPE…-values"><a href="#1，ObjectAnimator-ofXXX-Object-target-String-propertyName-TYPE…-values" class="headerlink" title="1，ObjectAnimator.ofXXX(Object target, String propertyName, TYPE… values)"></a>1，ObjectAnimator.ofXXX(Object target, String propertyName, TYPE… values)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title">ofXXX</span><span class="params">(Object target, String propertyName, XXX... values)</span> </span>&#123;</div><div class="line">    ObjectAnimator anim = <span class="keyword">new</span> ObjectAnimator(target, propertyName);</div><div class="line">    anim.setFloatValues(values);</div><div class="line">    <span class="keyword">return</span> anim;</div><div class="line">&#125;</div><div class="line">使用target创建ObjectAnimator，并使用propertyName创建PropertyValueHolder，将values值保存在PropertyValuesHolder中。</div></pre></td></tr></table></figure>
<p>setDuration等省略</p>
<h4 id="2，ObjectAnimator-start"><a href="#2，ObjectAnimator-start" class="headerlink" title="2，ObjectAnimator.start()"></a>2，ObjectAnimator.start()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">ValueAnimator</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> &#123;</div><div class="line">        <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</div><div class="line">        &#125;</div><div class="line">        AnimationHandler animationHandler = AnimationHandler.getInstance();</div><div class="line">        animationHandler.addAnimationFrameCallback(<span class="keyword">this</span>, (<span class="keyword">long</span>) (mStartDelay * sDurationScale);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mStartDelay == <span class="number">0</span> || mSeekFraction &gt;= <span class="number">0</span>) &#123;</div><div class="line">            startAnimation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="number">1</span>. 首先判断当前运行的动画的线程是否有looper，因为Animator的运行依赖looper(稍后介绍)。</div><div class="line"><span class="number">2</span>. 将当前Animator(ObjectAnimator)本身注册给AnimationHandler</div><div class="line"><span class="number">3</span>. 最后，设置一些动画标志位，完成PropertyValueHolder的一些初始化动作。</div></pre></td></tr></table></figure>
<h4 id="3，AnimationHandler-addAnimationFrameCallback"><a href="#3，AnimationHandler-addAnimationFrameCallback" class="headerlink" title="3，AnimationHandler.addAnimationFrameCallback()"></a>3，AnimationHandler.addAnimationFrameCallback()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Register to get a callback on the next frame after the delay.</div><div class="line">    */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAnimationFrameCallback</span><span class="params">(<span class="keyword">final</span> AnimationFrameCallback callback, <span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mAnimationCallbacks.size() == <span class="number">0</span>) &#123;</div><div class="line">        getProvider().postFrameCallback(mFrameCallback);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!mAnimationCallbacks.contains(callback)) &#123;</div><div class="line">        mAnimationCallbacks.add(callback);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</div><div class="line">        mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">AnimationHandler将创建的ObjectAnimator回调放入到一个ArrayList中mAnimationCallbacks，稍后在通知动画更新时，就是用此ArrayList，迭代遍历所有注册的ObjectAnimator，通知他们去更新自己的属性值。</div><div class="line"></div><div class="line">此处的Provider为MyFrameCallbackProvider</div><div class="line"><span class="comment">/**</span></div><div class="line">    * Default provider of timing pulse that uses Choreographer for frame callbacks.</div><div class="line">    */</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFrameCallbackProvider</span> <span class="keyword">implements</span> <span class="title">AnimationFrameCallbackProvider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Choreographer mChoreographer = Choreographer.getInstance();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallback</span><span class="params">(Choreographer.FrameCallback callback)</span> </span>&#123;</div><div class="line">        mChoreographer.postFrameCallback(callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCommitCallback</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">        mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getFrameTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mChoreographer.getFrameTime();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getFrameDelay</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Choreographer.getFrameDelay();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrameDelay</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">        Choreographer.setFrameDelay(delay);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Choreographer会在每次系统渲染Frame的时候，接收到一个脉冲信号，用以准备下一帧将要绘制内容的预备工作，可以在在Choreography注册监听，Choreographer.FrameCallback，在接到时间脉冲信号用于通知对此感兴趣的监听者。但是这个FrameCallback有个特别：在一个脉冲信号达到之后，这个callback就会失效，因此，如果你需要持续的监听，则需要在每次脉冲信号到达，完成自定义动作之后，再次将Callback注册一下，以便下次顺利接受回调。</div><div class="line"></div><div class="line">AnimationHanlder中定义了一个Choreographer.FrameCallback：</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">        <span class="comment">//doAnimationFrame(getProvider().getFrameTime());//稍后展开</span></div><div class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            getProvider().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">因此AnimationHandler.addAnimationFrameCallback中的写法：</div><div class="line"><span class="keyword">if</span> (mAnimationCallbacks.size() == <span class="number">0</span>) &#123;</div><div class="line">    getProvider().postFrameCallback(mFrameCallback);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!mAnimationCallbacks.contains(callback)) &#123;</div><div class="line">    mAnimationCallbacks.add(callback);</div><div class="line">&#125;</div><div class="line">意思就是统一使用一个Choreography.FrameCallback回调，如果mAnimationCallbacks不为空，表明已经有动画正在发生或者即将发生(延迟了),也就表明已经向Choreography注册了监听，就不需要再次注册，只需要将自己加入到FrameCallback的监听回调行列中就OK了。</div></pre></td></tr></table></figure>
<h4 id="4-Choreographer-postFrameCallback"><a href="#4-Choreographer-postFrameCallback" class="headerlink" title="4.Choreographer.postFrameCallback()"></a>4.Choreographer.postFrameCallback()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">postFrameCallback--&gt;postCallbackDelayedInternal--&gt;scheduleFrameLocked--&gt;scheduleVsyncLocked--&gt;mDisplayEventReceiver.scheduleVsync--&gt;nativeScheduleVsync</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></div><div class="line">        <span class="keyword">implements</span> <span class="title">Runnable</span> &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</div><div class="line">        mTimestampNanos = timestampNanos;</div><div class="line">        mFrame = frame;</div><div class="line">        Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        mHavePendingVsync = <span class="keyword">false</span>;</div><div class="line">        doFrame(mTimestampNanos, mFrame);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    mFrameInfo.markAnimationsStart();</div><div class="line">    doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</div><div class="line">    ...</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</div><div class="line">        ...</div><div class="line">        c.run(frameTimeNanos);</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"> 在AnimationHanlder调用Choreography.postFrameCallback的时候，FrameCallback封装成CallbackRecord，</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRecord</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> CallbackRecord next;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> dueTime;</div><div class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></div><div class="line">    <span class="keyword">public</span> Object token;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</div><div class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ((Runnable)action).run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-AnimationHandler-mFrameCallback"><a href="#5-AnimationHandler-mFrameCallback" class="headerlink" title="5. AnimationHandler.mFrameCallback"></a>5. AnimationHandler.mFrameCallback</h4><p>4步骤中，此刻token == FRAME_CALLBACK_TOKEN，执行if中的动作，调用的就是AnimationHandler中定义的Choreographer.FrameCallback：上面已经说过，但是上述中省略了最重要的一步：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">        doAnimationFrame(getProvider().getFrameTime());</div><div class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            getProvider().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = mAnimationCallbacks.size();</div><div class="line">    <span class="keyword">long</span> currentTime = SystemClock.uptimeMillis();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">final</span> AnimationFrameCallback callback = mAnimationCallbacks.get(i);</div><div class="line">        <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isCallbackDue(callback, currentTime)) &#123;</div><div class="line">            callback.doAnimationFrame(frameTime);</div><div class="line">            <span class="keyword">if</span> (mCommitCallbacks.contains(callback)) &#123;</div><div class="line">                getProvider().postCommitCallback(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        commitAnimationFrame(callback, getProvider().getFrameTime());</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cleanUpList();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="6-ValueAnimator-doAnimationFrame"><a href="#6-ValueAnimator-doAnimationFrame" class="headerlink" title="6. ValueAnimator.doAnimationFrame"></a>6. ValueAnimator.doAnimationFrame</h4><p>5步骤中callback为AnimationFrameCallback，ValueAnimator实现此接口，因此是调用的ValueAnimator中的doAnimationFrame：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</div><div class="line">    <span class="keyword">boolean</span> finished = animateBasedOnTime(currentTime);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (finished) &#123;</div><div class="line">        endAnimation();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">animateBasedOnTime</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (mRunning) &#123;</div><div class="line">        ...</div><div class="line">        mOverallFraction = clampFraction(fraction);</div><div class="line">        <span class="keyword">float</span> currentIterationFraction = getCurrentIterationFraction(mOverallFraction);</div><div class="line">        animateValue(currentIterationFraction);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> done;</div><div class="line">&#125;</div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object target = getTarget();</div><div class="line">    <span class="keyword">if</span> (mTarget != <span class="keyword">null</span> &amp;&amp; target == <span class="keyword">null</span>) &#123;</div><div class="line">        cancel();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.animateValue(fraction);</div><div class="line">    <span class="keyword">int</span> numValues = mValues.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</div><div class="line">        mValues[i].setAnimatedValue(target);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">super</span>:ValueAnimator.animateValue:</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</div><div class="line">    fraction = mInterpolator.getInterpolation(fraction);</div><div class="line">    mCurrentFraction = fraction;</div><div class="line">    <span class="keyword">int</span> numValues = mValues.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</div><div class="line">        mValues[i].calculateValue(fraction);<span class="comment">//Evalutor就是在这一步完成数值目标转换的</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> numListeners = mUpdateListeners.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">            mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">mValues为之前存放value值的PropertyValueHolder，由value的类型，又划分出FloatValuesHolder，IntValuesHolder，MultiFloatValuesHolder等等，在holder中计算当前的value值，然后调用Object对应的方法，更新属性：</div><div class="line">例如FloatValuesHolder：</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">   ...</div><div class="line">    <span class="keyword">if</span> (mJniSetter != <span class="number">0</span>) &#123;</div><div class="line">        nCallFloatMethod(target, mJniSetter, mFloatAnimatedValue);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mTmpValueArray[<span class="number">0</span>] = mFloatAnimatedValue;</div><div class="line">            mSetter.invoke(target, mTmpValueArray);</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="7-循环流程，直到timeout"><a href="#7-循环流程，直到timeout" class="headerlink" title="7.循环流程，直到timeout"></a>7.循环流程，直到timeout</h4><p>以上步骤为一个动画在一帧中的完整流程，只要动画尚未完成，Animator就不会将自己从AnimationHandler中的监听List中删除，则Choreography.FrameCallback就会持续的注册，监听回调完成后续帧中动画变化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">AnimationHandler:</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">        doAnimationFrame(getProvider().getFrameTime());</div><div class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            getProvider().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ValueAnimator:</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endAnimation</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mAnimationEndRequested) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    AnimationHandler handler = AnimationHandler.getInstance();</div><div class="line">    handler.removeCallback(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    mAnimationEndRequested = <span class="keyword">true</span>;</div><div class="line">    mPaused = <span class="keyword">false</span>;</div><div class="line">    ...</div><div class="line">    mRunning = <span class="keyword">false</span>;</div><div class="line">    mStarted = <span class="keyword">false</span>;</div><div class="line">    mStartListenersCalled = <span class="keyword">false</span>;</div><div class="line">    mReversing = <span class="keyword">false</span>;</div><div class="line">    mLastFrameTime = <span class="number">0</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-小结："><a href="#3-小结：" class="headerlink" title="3, 小结："></a>3, 小结：</h3><ol>
<li>使用多个Animator，AnimatorSet，或者PropertyValueHolder在性能上并没有明显的差异，他们之间的关系大体如下所示：<br><img src="/2017/08/27/Android动画实现原理浅析/single_multi_anim.png" alt="多个Animator的关系"></li>
</ol>
<p>注意到：总体调用对象的次数没有发生变化。</p>
<ol>
<li>如果多个Animator都是操作同一个View的UI属性，则在每一个PropertyValueHolder每次被更新并调用View对应的方法时，就会多次调用view.invalidate和requestlayout方法。这样就会执行很多次非必要的方法，这是就可以考虑使用ViewPropertyAnimator：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">textview.animate().x(<span class="number">500</span>).y(<span class="number">500</span>).setDuration(<span class="number">5000</span>).setInterpolator(<span class="keyword">new</span> BounceInterpolator());</div><div class="line">ViewPropertyAnimator不能直接创建实例对象，只能通过view.animate()来获得针对此View的实例。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>通过查看ViewPropertyAnimator的实现，其实在其内部也是使用的ValueAnimator来实现的view的动画效果，但是呢，ViewPropertyAnimator针对多个Animator调用时的缺点，进行了优化，以提高性能（将需要使用动画的属性，放到一个Map里面，等待下一次的帧更新动作，然后在帧更新时，使用View内部存储的RenderNode节点，将各个属性值设置上去，然后调用View.invalidateViewProperty()(简化版的invalidate操作)）；</p>
<p>但是使用中应该注意，ViewPropertyAnimator不能在外部持有其实例，以便以后反复使用，必须每次通过View.animate来获得实例。</p>
<ol>
<li>接下来就要分析一下在支持硬件加速的机器上，针对动画开启硬件加速的一些功能。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/RxJava应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lyhighfly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myself.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="低级Debuger">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/RxJava应用/" itemprop="url">RxJava应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-20T15:24:51+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TODO-如果发生异常，OnError，Action1运行的线程所在？？？？"><a href="#TODO-如果发生异常，OnError，Action1运行的线程所在？？？？" class="headerlink" title="TODO 如果发生异常，OnError，Action1运行的线程所在？？？？"></a>TODO 如果发生异常，OnError，Action1<throwable>运行的线程所在？？？？</throwable></h1><h1 id="TODO-map-和-flatMap-的原理"><a href="#TODO-map-和-flatMap-的原理" class="headerlink" title="TODO map 和 flatMap 的原理"></a>TODO map 和 flatMap 的原理</h1><h1 id="TODO-与Retrofit的结合使用"><a href="#TODO-与Retrofit的结合使用" class="headerlink" title="TODO 与Retrofit的结合使用"></a>TODO 与Retrofit的结合使用</h1><h1 id="TODO-RxBinding，RxLifeCycle的应用"><a href="#TODO-RxBinding，RxLifeCycle的应用" class="headerlink" title="TODO RxBinding，RxLifeCycle的应用"></a>TODO RxBinding，RxLifeCycle的应用</h1><h2 id="什么是响应式-Reactive"><a href="#什么是响应式-Reactive" class="headerlink" title="什么是响应式(Reactive):"></a>什么是响应式(Reactive):</h2><p>应用开发中的例子：<br>搜索输入框，根据用户实时输入的数据，输入框下方会根据当前输入内容，实时刷新推荐信息，这种就叫做Reactive的能力。<br>类似这种能自动对外部环境的变化做出响应的系统，我们就称之为响应式系统(Reactive System)，其中的外部环境，可以是输入信号的变化，事件的发生等等。通常这个响应式系统不但能响应外部环境的变化，还会根据自身内部状态通过某种方式反馈给外部观察者(推荐内容变化)。</p>
<h2 id="什么是函数式编程-Functional-Programming"><a href="#什么是函数式编程-Functional-Programming" class="headerlink" title="什么是函数式编程(Functional Programming):"></a>什么是函数式编程(Functional Programming):</h2><p> <a href="https://www.zhihu.com/question/28292740" target="_blank" rel="external">函数式编程介绍</a><br> <a href="http://www.infoq.com/cn/articles/functional-reactive-programming?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="external">介绍Callback形式和响应式区别</a><br> <a href="http://www.devtf.cn/?p=323" target="_blank" rel="external">一篇不错的Java响应式导读</a></p>
<p>有别于命令式编程，逻辑式编程的一种编程范式，是一种面向数学的抽象，将计算描述为一种表达式求值，而这个表达式就是函数，求值的过程称之为自变量的映射。也就是说一个函数的求值结果，仅取决于自变量和函数本身，不依赖其他状态变量(也就是闭包), 也不修改其他外部变量，没有副作用。自变量可以是常规的变量，也可以是另一个函数(高阶函数)。(当然还有一些其他属性和特征，不详细介绍了)</p>
<h2 id="什么是响应式编程-Reactive-Programming-："><a href="#什么是响应式编程-Reactive-Programming-：" class="headerlink" title="什么是响应式编程(Reactive Programming)："></a>什么是响应式编程(Reactive Programming)：</h2><p>响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p>
<h4 id="函数响应式编程-函数式-响应式-—-gt-函数响应式-Functional-Reactive-Programming"><a href="#函数响应式编程-函数式-响应式-—-gt-函数响应式-Functional-Reactive-Programming" class="headerlink" title="函数响应式编程(函数式+响应式 —&gt; 函数响应式 Functional Reactive Programming)"></a>函数响应式编程(函数式+响应式 —&gt; 函数响应式 Functional Reactive Programming)</h4><h3 id="TODO-编程范式关系图"><a href="#TODO-编程范式关系图" class="headerlink" title="TODO 编程范式关系图"></a>TODO 编程范式关系图</h3><ul>
<li>利用函数式编程的思想和方法(闭包思想，函数、高阶函数)，来为响应式：事件流，变化传播所用。</li>
</ul>
<h3 id="监听状态变化Callback方式的弊端："><a href="#监听状态变化Callback方式的弊端：" class="headerlink" title="监听状态变化Callback方式的弊端："></a>监听状态变化Callback方式的弊端：</h3><ol>
<li>状态的修改可能分布很多地方，针对状态而作响应动作的地方，也就线性增长；</li>
<li>状态之间可能相互组合，相互影响，不集中管理，有可能出bug，而且很有可能出现未考虑的状态组合；</li>
<li>多重回调，难于调试和跟踪，回调之间关系不清晰；</li>
<li>尤其是在Android中，有UI操作，非UI操作之分，一些必须在UI中，一些一定不能在UI线程中去做。使用Callback难以实现线程的轻松切换</li>
</ol>
<p>而在Java，Android中使用的函数响应式编程框架就是：RxJava，RxAndroid</p>
<p><br><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava的GitHub</a>：函数响应式编程的主框架</p>
<p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid的GitHub</a>：在RxJava基础上针对Android的扩展，用的最多的就是UI线程的切换</p>
<h3 id="（1）-什么是RxJava："><a href="#（1）-什么是RxJava：" class="headerlink" title="（1） 什么是RxJava："></a>（1） 什么是RxJava：</h3><blockquote>
<p>摘自GitHub上的一句话介绍：RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.(RxJava 是针对JVM的响应式编程思想的实现，一个使用可观测序列来组成<em>异步</em>和<em>基于事件</em>的library)。</p>
</blockquote>
<p>RxJava的设计思想，就是观察者模式(Observer Pattern)：</p>
<p>Obserable：序列化产生事件的对象；Observer：观察者、订阅者，监听到变化后做出相应的动作。</p>
<p>Obserable和Observer通过subscribe()方法实现订阅(观察，监听)关系，从而在Obserable可以在发生变化的时候通知Observer，并且在完成通知任务之后，又追加了几个方法调用 — error的通知，complete的通知。</p>
<h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"h"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"e"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"l"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"l"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">&#125;&#125;);<span class="comment">//创造一个最基本的事件序列，在被订阅时，依次将预定事件发送给观察者。</span></div><div class="line"></div><div class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer onCompleted"</span>);    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer onError"</span>);    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String o)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer onNext:"</span>+o);    &#125;</div><div class="line">&#125;;</div><div class="line">observable.subscribe(observer);<span class="comment">//发生订阅</span></div></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li><p>只有订阅发生是(observable.subscribe(observer))，事件流才会启动</p>
</li>
<li><p>队列完结是，需要调用onCompleted()，作为事件完结的标志(只有在自定义事件源时才需要这么做)</p>
</li>
<li><p>onComplete和onError是互斥事件</p>
</li>
<li><p>onError()：在事件队列发生异常时，会触发，同时队列自动终止，不允许再有事件发出</p>
</li>
</ol>
<p>以上代码中，Observer定义了一套完整的监听事件，其中包括：每一次事件发生的监听onNext；发射源完成所有发射任务最后的事件：onComplete；如果在事件发射处理过程中有错误发生时：onError。</p>
<p>有时候订阅者(Observer)可能只关心以上三种事件中的几种，也可以定义一个不完整的监听，只定义自己感兴趣的事件，不关心的事件不需要定义。</p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//只对next事件感兴趣：</span></div><div class="line">Observable.just(<span class="string">"hello"</span>, <span class="string">"world"</span>).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer call:"</span>+s);    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//只对next事件或者有可能发生的error感兴趣：</span></div><div class="line">Observable.just(<span class="string">"hello"</span>, <span class="string">"world"</span>).subscribe(</div><div class="line">    <span class="keyword">new</span> Action1&lt;String&gt;() &#123;<span class="comment">//next</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer call:"</span>+s);    &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;<span class="comment">//error</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Oops Error :"</span>+throwable);    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//甚至于对什么都不感兴趣，只是想让被观察者的事件发生：</span></div><div class="line">Observable.just(<span class="string">"hello"</span>, <span class="string">"world"</span>).subscribe();</div></pre></td></tr></table></figure></p>
<p>关于以上几种情况，源代码都有相应的重载方法原型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">()</span>；</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext)</span>；</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext, <span class="keyword">final</span> Action1&lt;Throwable&gt; onError)</span>；</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext, <span class="keyword">final</span> Action1&lt;Throwable&gt; onError, <span class="keyword">final</span> Action0 onCompleted)</span>；</div></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到，从不监听任何事件到监听所有事件，都有方法原型声明。null —&gt;(next) —&gt; (next, error) —&gt; (next, error, complete)；但是不能打破顺序跳跃式监听：例如一下：Obserable.subscribe(new Action1<throwable>) 或者    Obserable.subscribe(new Action0 onCompleted)。而且如果事件队列中途发生错误，而你又没有注册响应的监听事件，就会抛出异常：OnErrorNotImplementedException。因此，缺省监听，最保险的方式是一定要注册Next事件和Error事件。</throwable></p>
</blockquote>
<h3 id="（2）-RxJava常用操作符介绍：官网所列所有操作符-非常庞大"><a href="#（2）-RxJava常用操作符介绍：官网所列所有操作符-非常庞大" class="headerlink" title="（2） RxJava常用操作符介绍：官网所列所有操作符(非常庞大)"></a>（2） RxJava常用操作符介绍：<a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="external">官网所列所有操作符(非常庞大)</a></h3><h5 id="TODO-常用操作符图文介绍"><a href="#TODO-常用操作符图文介绍" class="headerlink" title="TODO 常用操作符图文介绍"></a>TODO 常用操作符图文介绍</h5><ol>
<li>create</li>
<li>just/from</li>
<li>map</li>
<li>flatMap</li>
<li>timer</li>
<li>interval</li>
<li>range</li>
<li>concat</li>
<li>merge/mergeDelayError</li>
<li>startWith</li>
<li>zip</li>
<li>combineLatest/combineLatestDelayError(结合Reader同步更新书架实例)</li>
<li>filter</li>
<li>take/takeLast/takeLastBuffer/takeFirst</li>
<li>ofType</li>
<li>skip/skipLast</li>
<li>elementAt</li>
<li>distinct</li>
<li>throttleFirst/throttleLast</li>
<li>reduce</li>
<li>collect</li>
<li>count</li>
<li>buffer</li>
<li>toList/toSortedList/toMap</li>
</ol>
<h3 id="（3）-RxJava中的线程切换"><a href="#（3）-RxJava中的线程切换" class="headerlink" title="（3） RxJava中的线程切换"></a>（3） RxJava中的线程切换</h3><p>以上栗子中，没有涉及到线程切换的问题，因此都是按照默认的线程在运行：事件的发出和事件的接收在同一个线程中完成，两者所在线程由订阅动作(subscribe)发生的线程所决定。<br>RxJava的主要优势：1，避免了回调地狱；2，便利的线程切换。<br></p>
<p>因此，接下来就要开始最主要的特征了，事件流中的线程切换：Scheduler</p>
<p>还是上面的打印字符的事件栗子，这次主要关注Obserable和Observer的所处线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"hello word"</span>);</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observable  onCompleted in Thread :"</span>+ Thread.currentThread().getName());</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">final</span> Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer receive onCompleted in Thread :"</span>+ Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String o)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"liuyu"</span>, <span class="string">"Observer receive onNext in Thread :"</span>+ Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//方便在开始一个订阅任务发生的开始时刻，添加一些额外的动作，比如开始一个网络请求之前，先显示一个loading的页面等等, 注意，在下面的subscribe代码分析中揭示了，此回调发生在subscribe调用所在的线程，因为要特别注意耗时与否</span></div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">observable</div><div class="line">    .subscribeOn(Schedulers.io()) <span class="comment">//事件发出所在线程</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">//事件接收者所在线程</span></div><div class="line">    .subscribe(observer);</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">输出结果：</div><div class="line">Observable  onCompleted in Thread  :Thread-<span class="number">2141</span></div><div class="line">Observer receive onNext in Thread : main</div><div class="line">Observer receive onCompleted in Thread :main</div></pre></td></tr></table></figure>
<p>可以看到通过在订阅是通过方法：subscribeOn，observeOn指定了事件双方分属的线程。这里，我们主要关注的就是Schedulers(调度器)，RxJava就是通过调度器来指定代码应该运行在什么样的线程中，RxJava中已经内置了几种常用的Scheduler：</p>
<ul>
<li>Schedulers.io():I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程;</li>
<li>Schedulers.immediate():直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler;</li>
<li>Schedulers.newThread():总是启用新线程，并在新线程执行操作;</li>
<li>Schedulers.computation():计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU;</li>
<li>Schedulers.trampoline():将其放在当前线程中任务队列中，当前线程中任务完成之后开始执行;</li>
<li>AndroidSchedulers.mainThread():RxAndroid依赖库中使用最频繁的方法，指定运行在主线程(UI线程)中;</li>
</ul>
<h4 id="3-1-不包含线程切换的订阅发生逻辑："><a href="#3-1-不包含线程切换的订阅发生逻辑：" class="headerlink" title="(3.1) 不包含线程切换的订阅发生逻辑："></a>(3.1) 不包含线程切换的订阅发生逻辑：</h4><pre><code>在分析订阅者，被订阅者线程切换的逻辑之前，先将没有任何线程切换的原始版本订阅发生过程，撸一遍，在搞明白这个后，就可以循循渐进的搞明白，订阅者，被订阅者分别运行的线程是怎么切换的。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以下代码非完整版本，只保留主干。</span></div><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// new Subscriber so onStart it</span></div><div class="line">        subscriber.onStart();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// allow the hook to intercept and/or decorate,RxJavaHooks是用于hook 各种Observable生命周期行为的工具类，此处将其替换成真实的运行步骤</span></div><div class="line">            <span class="comment">//RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);</span></div><div class="line">            <span class="comment">//return RxJavaHooks.onObservableReturn(subscriber);</span></div><div class="line">            observable.onSubscribe.call(subscriber);①</div><div class="line">            <span class="keyword">return</span> (Subscription)subscriber;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="keyword">if</span> (subscriber.isUnsubscribed()) &#123;</div><div class="line">                <span class="comment">//RxJavaHooks.onError(RxJavaHooks.onObservableError(e));</span></div><div class="line">                observable.onSubscribe.callError(subscriber);<span class="comment">//杜撰的方法调用</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//return Subscriptions.unsubscribed();</span></div><div class="line">            <span class="keyword">return</span> (Subscription)subscriber;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>抛除各种关于Observer，Observable的包装，上述代码就是订阅发生之后，Observable emits items 的步骤，对照如下应用示例，大概就可以撸顺整个订阅发生的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;②</div><div class="line">        subscriber.onNext(<span class="string">"hello word"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;④</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String o)</span> </span>&#123;③</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"> observable.subscribe(observer);</div></pre></td></tr></table></figure></p>
<p>在Observable.onSubscribe的call回调中，参数为Subscriber，而我们定义的类型为Observer，这两者是什么关系呢？</p>
<p>Subscriber是Observer接口的实现类，除了实现Observer接口定义的onNext，onError，onComplete方法之外，提供额外的回调(例如onStart)和取消订阅(unsubscribe(),isUnsubscribed())等方法，<br>如果上述示例中，直接使用了Observer，而不是Subscriber，在底层，是会自动将其包装成Subscriber的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (observer <span class="keyword">instanceof</span> Subscriber) &#123;</div><div class="line">        <span class="keyword">return</span> subscribe((Subscriber&lt;? <span class="keyword">super</span> T&gt;)observer);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (observer == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"observer is null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> ObserverSubscriber&lt;T&gt;(observer));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-2-带线程切换的订阅动作："><a href="#3-2-带线程切换的订阅动作：" class="headerlink" title="(3.2) 带线程切换的订阅动作："></a>(3.2) 带线程切换的订阅动作：</h4><ol>
<li>Observable.subscribeOn():<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obserable</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> requestOn)</span> </span>&#123;</div><div class="line">        <span class="comment">//TODO ScalarSynchronousObservable是什么？？？</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">            <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> unsafeCreate(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, requestOn));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">unsafeSubscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ......</div><div class="line">            RxJavaHooks.onObservableStart(<span class="keyword">this</span>, onSubscribe).call(subscriber);</div><div class="line">            <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            ......</div><div class="line">            subscriber.onError(RxJavaHooks.onObservableError(e));</div><div class="line">            ......</div><div class="line">            <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Scheduler scheduler;</div><div class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> requestOn;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler, <span class="keyword">boolean</span> requestOn)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">        <span class="keyword">this</span>.requestOn = requestOn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Worker inner = scheduler.createWorker();</div><div class="line"></div><div class="line">        SubscribeOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnSubscriber&lt;T&gt;(subscriber, requestOn, inner, source);</div><div class="line">        subscriber.add(parent);</div><div class="line">        subscriber.add(inner);</div><div class="line"></div><div class="line">        <span class="comment">//根据Schedulers产生不同的线程切换动作</span></div><div class="line">        inner.schedule(parent);</div><div class="line">        ++++++++++++++++++++++++++++++++++</div><div class="line">            摘选一个Schedulers.newThread()的具体实现来看一下调用逻辑：CachedThreadSchedluer</div><div class="line">            ......</div><div class="line">            ......</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(Action0 action)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> schedule(action, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (innerSubscription.isUnsubscribed()) &#123;</div><div class="line">                    <span class="comment">// don't schedule, we are unsubscribed</span></div><div class="line">                    <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ScheduledAction s = threadWorker.scheduleActual(<span class="keyword">new</span> Action0() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">if</span> (isUnsubscribed()) &#123;</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//实际调用为SubscribeOnSubscriber.call()，此时已经完成线程切换</span></div><div class="line">                        action.call();</div><div class="line">                    &#125;</div><div class="line">                &#125;, delayTime, unit);</div><div class="line">                innerSubscription.add(s);</div><div class="line">                s.addParent(innerSubscription);</div><div class="line">                <span class="keyword">return</span> s;</div><div class="line">            &#125;</div><div class="line">            ......</div><div class="line">            ......</div><div class="line">        ++++++++++++++++++++++++++++++++++</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeOnSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; actual;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> requestOn;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Worker worker;</div><div class="line"></div><div class="line">        Observable&lt;T&gt; source;</div><div class="line"></div><div class="line">        Thread t;</div><div class="line"></div><div class="line">        SubscribeOnSubscriber(Subscriber&lt;? <span class="keyword">super</span> T&gt; actual, <span class="keyword">boolean</span> requestOn, Worker worker, Observable&lt;T&gt; source) &#123;</div><div class="line">            <span class="keyword">this</span>.actual = actual;</div><div class="line">            <span class="keyword">this</span>.requestOn = requestOn;</div><div class="line">            <span class="keyword">this</span>.worker = worker;</div><div class="line">            <span class="keyword">this</span>.source = source;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">            actual.onNext(t);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                actual.onError(e);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                worker.unsubscribe();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                actual.onCompleted();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                worker.unsubscribe();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;<span class="comment">//注意：此时已经切换为Worker指定的线程了</span></div><div class="line">            Observable&lt;T&gt; src = source;</div><div class="line">            source = <span class="keyword">null</span>;</div><div class="line">            t = Thread.currentThread();</div><div class="line">            <span class="comment">//原Observable将items发射给当前这个Subscriber(SubscribeOnSubscriber),然后actual(Subscriber)再去将事件进行下一步的分发。</span></div><div class="line">            src.unsafeSubscribe(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        。。。。。。</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">如同上述例子中的Observable.create(OnSubscribe), unsafeCreate方法有产生了一个Observable,并且订阅的新事件为OnSubscribe( = OperatorSubscribeOn)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>至此，调用链为：</p>
<ol>
<li>Observable.create():创建了Observable-1和OnSubscribe-1；</li>
<li>subscribeOn():创建了Observable-2和OperatorSubscribeOn(OnSubscribe-2)，同时，OnSubscribe-2中保存了Observable-1的引用。</li>
<li>Obserable-2.subscribe(Observer):调用了OnSubscribe-2的call方法，在call方法中，通过Schedulers发生了线程切换，线程完成切换之后，调用了Observale-1.unsafeSubscribe(Obserable-2内部实现Subscriber)，此时OnSubscribe-1的call方法被调用，并且发生在Obsubscribe-2.SubscribeOnSubscriber.call所在的线程，此时就完成了源Observable.OnSubscribe发射事件的线程切换。</li>
</ol>
<p>如果多个subscribeOn链接，那么此时，Obserable.OnSubscribe究竟发生在哪个线程呢？？？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"ss"</span>) </div><div class="line">            .subscribeOn(Schedulers.io())   <span class="comment">// --thread-1---</span></div><div class="line">            .subscribeOn(Schedulers.newThread()) <span class="comment">//--thread-2----</span></div><div class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div></pre></td></tr></table></figure>
<p>下面来分析一下这个例子中的线程切换流程：</p>
<pre><code>1，Obserable.just() : 产生Observable-1, OnSubscribe-1

2,Observable-1.subscribeOn(Schedulers.io()) : 产生了Obserable-2, OperatorSubscribeOn-2，并在OperatorSubscribeOn-2中保存了Obserable-1的引用。

3，了Obserable-2..subscribeOn(Schedulers.newThread())：创建Observable-3, OperatorSubscribeOn-3并在OperatorSubscribeOn-3保存Observable-2的引用。

4，Obserable-3.subscribe():
    调用OperatorSubscribeOn_3.call(),改变线程为Schedulers.newThread()。
    调用OperatorSubscribeOn_2.call(),改变线程为Schedulers.io()。
    调用OnSubscribe_1.call(),此时call()运行在Schedulers.io()。
</code></pre><p>根据以上逻辑分析，会按照thread-1的线程进行执行。</p>
<blockquote>
<p>总结：subscribeOn的调用，会改变调用前事件运行的线程，多次调用subscribeOn，只有头部的subscribeOn起作用。<br><img src="/2017/08/20/RxJava应用/rxjava-subsribeon.png" alt="RxJava.subscribeOn线程切换逻辑"></p>
</blockquote>
<ol>
<li>Observable.observeOn():</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">示例：</div><div class="line"></div><div class="line">Observable.just(<span class="string">"ss"</span>) </div><div class="line">    .observeOn(Schedulers.io())</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obserable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">            <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> unsafeCreate(<span class="keyword">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeLift</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> OnSubscribe&lt;T&gt; parent;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeLift</span><span class="params">(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">        <span class="keyword">this</span>.operator = operator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Subscriber&lt;? <span class="keyword">super</span> T&gt; st = operator.call(o);</div><div class="line">            ...</div><div class="line">            st.onStart();</div><div class="line">            parent.call(st);</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            ...</div><div class="line">            o.onError(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Operator</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class="line">        parent.init();</div><div class="line">        <span class="keyword">return</span> parent;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">         <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">            Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = child;</div><div class="line"></div><div class="line">            localChild.setProducer(<span class="keyword">new</span> Producer() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (n &gt; <span class="number">0L</span>) &#123;</div><div class="line">                        BackpressureUtils.getAndAddRequest(requested, n);</div><div class="line">                        schedule();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;);</div><div class="line">            localChild.add(recursiveScheduler);</div><div class="line">            localChild.add(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            schedule();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            finished = <span class="keyword">true</span>;</div><div class="line">            schedule();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable e)</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            finished = <span class="keyword">true</span>;</div><div class="line">            schedule();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;</div><div class="line">                recursiveScheduler.schedule(<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// only execute this from schedule()</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> Queue&lt;Object&gt; q = <span class="keyword">this</span>.queue;</div><div class="line">            <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = <span class="keyword">this</span>.child;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">long</span> requestAmount = requested.get();</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (requestAmount != currentEmission) &#123;</div><div class="line">                    <span class="keyword">boolean</span> done = finished;</div><div class="line">                    Object v = q.poll();</div><div class="line">                    <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (checkTerminated(done, empty, localChild, q)) &#123;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (empty) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    localChild.onNext(NotificationLite.&lt;T&gt;getValue(v));</div><div class="line"></div><div class="line">                    ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//完成或者异常时的退出</span></div><div class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">checkTerminated</span><span class="params">(<span class="keyword">boolean</span> done, <span class="keyword">boolean</span> isEmpty, Subscriber&lt;? <span class="keyword">super</span> T&gt; a, Queue&lt;Object&gt; q)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (a.isUnsubscribed()) &#123;</div><div class="line">                q.clear();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (done) &#123;</div><div class="line">            ...</div><div class="line">                Throwable e = error;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">                        a.onError(e);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        a.onCompleted();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    recursiveScheduler.unsubscribe();</div><div class="line">                &#125;</div><div class="line">            ...</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，调用链为：</p>
<ol>
<li>Obserable.create() : 创建了Observable-1 ，OnSubscriber-1;</li>
<li>observeOn : 创建了Obserable-2，OnSubscriber-2(OnSubcribeLift)持有OnSubscriber-1的引用，和一个线程变换动作OperatorObserverOn；</li>
<li><p>subscribe(Subscriber-final) :</p>
<p> ① OperatorObserveOn完成线程切换的准备工作，并持有了最终的Suscriber-final(缓存起来)，并以此构造了一个Obserable-1需要使用的Subscriber-temp;</p>
<p> ② Obserable-1调用call(Subscriber)方法，实际是调用了①中创建的Subscriber-temp，如上，Subsriber-temp中的onNext，onComplete，onError，都没有直接调用真实的Subsriber-final对应的方法回调(废话，这样就相当于倒手传递了一下发射的事件，什么都没有做)，而是使用调度方法schedule，触发线程切换动作。</p>
<p> ③ Subscriber-temp 在线程切换之后，回调call方法中，取出①中缓存的Suscriber-final，调用Subscriber-final的onNext，onComplete，onError。</p>
</li>
</ol>
<h4 id="TODO-observeOn的流程图"><a href="#TODO-observeOn的流程图" class="headerlink" title="TODO observeOn的流程图"></a>TODO observeOn的流程图</h4><h4 id="3-3-subscribeOn、observeOn"><a href="#3-3-subscribeOn、observeOn" class="headerlink" title="(3.3)subscribeOn、observeOn"></a>(3.3)subscribeOn、observeOn</h4><p>综上，subscribeOn关注的是OnSubscriber，observeOn关注的是subscriber.onNext()。</p>
<p>subcribeOn和observeOn 对比分析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable</div><div class="line">.map                    <span class="comment">// 操作1</span></div><div class="line">.flatMap                <span class="comment">// 操作2</span></div><div class="line">.subscribeOn(io)</div><div class="line">.map                    <span class="comment">//操作3</span></div><div class="line">.flatMap                <span class="comment">//操作4</span></div><div class="line">.observeOn(main)</div><div class="line">.map                    <span class="comment">//操作5</span></div><div class="line">.flatMap                <span class="comment">//操作6</span></div><div class="line">.subscribeOn(io)        <span class="comment">//!!特别注意</span></div><div class="line">.subscribe(handleData)</div></pre></td></tr></table></figure></p>
<p>有如上逻辑，则我们对其运行进行分析。</p>
<p>首先，我们需要先明白其内部执行的逻辑。</p>
<p>在调用subscribe之后，逻辑开始运行。分别调用每一步OnSubscribe.call()，注意：自下往上。当运行到最上，即Observable.create()后，我们在其中调用了subscriber.onNext(),于是程序开始自上往下执行每一个对象的subscriber.onNext()方法。最终，直到subscribe()中的回调。</p>
<p>其次，从上面对subscribeOn()和observeOn()的分析中可以明白，subscribeOn()是在call()方法中起作用，而observeOn()是在onNext()中作用。</p>
<p>那么对于以上的逻辑，我们可以得出如下结论：</p>
<p>操作1,2,3,4在io线程中，因为在如果没有observeOn()影响，他们的回调操作默认在订阅的线程中。而我们的订阅线程在subscribeOn(io)发生了改变。注意他们执行的先后顺序。<br>操作5,6在main线程中运行。因为observeOn()改变了onNext().<br>特别注意那一个逻辑没起到作用<br>再简单点总结就是</p>
<p>subscribeOn的调用切换之前的线程。<br>observeOn的调用切换之后的线程。<br>observeOn之后，不可再调用subscribeOn 切换线程<br>复杂情况</p>
<p>我们经常多次使用subscribeOn切换线程，那么以后是否可以组合observeOn和subscribeOn达到自由切换的目的呢？</p>
<p>组合是可以的，但是他们的执行顺序是有条件的，如果仔细分析的话，可以知道observeOn调用之后，再调用subscribeOn是无效的，原因是什么？</p>
<p>因为subscribeOn改变的是subscribe这句调用所在的线程，大多数情况，产生内容和消费内容是在同一线程的，所以改变了产生内容所在的线程，就改变了消费内容所在的线程。</p>
<p>经过上面的阐述，我们知道，observeOn的工作原理是把消费结果先缓存，再切换到新线程上让原始消费者消费，它和生产者是没有一点关系的，就算subscribeOn调用了，也只是改变observeOn这个消费者所在的线程，和OperatorObserveOn中存储的原始消费者一点关系都没有，它还是由observeOn控制。</p>
<p>下面提到的“操作”包括产生事件、用操作符操作事件以及最终的通过 subscriber 消费事件；</p>
<ol>
<li>只有第一subscribeOn() 起作用（所以多个 subscribeOn() 无意义；</li>
<li>这个 subscribeOn() 控制从流程开始的第一个操作，直到遇到第一个 observeOn()；</li>
<li>observeOn() 可以使用多次，每个 observeOn() 将导致一次线程切换()，这次切换开始于这次 observeOn() 的下一个操作；<br>不论是 subscribeOn() 还是 observeOn()，每次线程切换如果不受到下一个 observeOn() 的干预，线程将不再改变，不会自动切换到其他线程。</li>
</ol>
<h3 id="3-发生错误时的逻辑处理"><a href="#3-发生错误时的逻辑处理" class="headerlink" title="3. 发生错误时的逻辑处理"></a>3. 发生错误时的逻辑处理</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/03/Android-App冷启动优化的一些经验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lyhighfly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myself.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="低级Debuger">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/03/Android-App冷启动优化的一些经验/" itemprop="url">Android App冷启动优化的一些经验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-03T21:30:57+08:00">
                2017-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;关于Android App的优化，百度，Google已经收录了不计其数的文章。常规套路我相信大家基本上应该都可以如数家珍了吧。尤其是国内的技术环境，大众化的，易于理解和实践的优化方式和方法，被粘贴过来，复制过去。无非也就是使用系统提供的工具，例如Traceview, Hierarchyviewer，DDMS，MAT等等，去分析方法的调用，View的层级，内存的占用和一些其他的影响App性能表现的Key。随便查阅四五篇，也就了然于胸了。相比而言，Google搜到的外文技术文章，还有一些App优化的独到见解和处理方式方法，这个会在下文中有所提及。<br>&emsp;&emsp;所以呢，常规套路在这里我就不准备写了，由于最近半年断断续续的都在做Sogou浏览器的冷启动优化，就分享一下在浏览器冷启动优化过程中的一些经验和一些接下来怎么去进一步优化整个App的想法吧。</p>
<blockquote>
<p>说明：这里所说的冷启动，是指非第一次安装的冷启动。由于Android 方法数的限制，Google引入了MultiDex，也正是因为安装包内多了几个Dex文件，导致在第一次安装启动的过程中，多个Dex要做合并编译的优化处理，所以在Sogou浏览器引入的Moudle越来越多的现实状况下，第一次安装启动的时间被拉的越来越长。这一块的优化涉及的技术比较专深，就让负责优化的同事来讲吧。：P </p>
</blockquote>
<h3 id="Sogou浏览器的冷启动优化"><a href="#Sogou浏览器的冷启动优化" class="headerlink" title="Sogou浏览器的冷启动优化"></a>Sogou浏览器的冷启动优化</h3><p>&emsp;&emsp;冷启动时间：从用户点击桌面的ICON到，App启动并展示在前台，可以与用户产生交互的这段时间。冷启动的优化，说的直白一些，就是尽量让App启动的时间变短。假如用户从点击icon到App启动耗费的时间都够用户思考人生了，99%的用户会毫不犹豫的卸载掉咱么的应用，用户的留存率会直线下降。<br>&emsp;&emsp;因此，冷启动的优化，贯穿浏览器的迭代中，每一版在不停的添加模块，添加功能的同时，在灰度上线的前夕专门预留时间来做冷启动的优化，以保证功能增加，时间不加长。<br>每一版的首页架构不同，因此优化的方法也不尽相同，尤其是4.x版本到5.x版本的优化方式，更改较大。今天就着重介绍一下从浏览器5.0版之后的一处优化小细节：</p>
<h4 id="0，衡量标准："><a href="#0，衡量标准：" class="headerlink" title="0，衡量标准："></a>0，衡量标准：</h4><blockquote>
<p>衡量冷启动优化的效果，总要有一个标准，QA的同学是通过摄像头采点的方法来获取冷启动的时间信息的。我们则可以通过adb的命令得到接近的效果，虽然完全启动用户可见的时间点可能会较QA的测试有所不同，但是作为纵向对比工具已经足够了。</p>
</blockquote>
<p><img src="http://up.1.sogou.com/files/2016/10/28/627e0dc3401985c603e025bf225be7f3.png" alt="&quot;adb命令&quot;" title="adb命令"></p>
<h5 id="以下摘自其他人的博客："><a href="#以下摘自其他人的博客：" class="headerlink" title="以下摘自其他人的博客："></a>以下摘自其他人的博客：</h5><p>“adb shell am start -W ”的实现在frameworks\base\cmds\am\src\com\android\commands\am\Am.java文件中。其实就是跨Binder调用ActivityManagerService.startActivityAndWait()接口,然后等待返回结果，结束本次启动过程并将统计数据打印出来。（后面将ActivityManagerService简称为AMS），<br><img src="http://up.1.sogou.com/files/2016/10/28/8ccff652ff16a76045ff90f69d36cd8d.png" alt=""><br>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br><img src="http://up.1.sogou.com/files/2016/10/28/260b26499bc64cdbece26ac221b3335f.png" alt=""></p>
<p>result中的thisTime，totalTime时间的计算，是在：frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java中：<br><img src="http://up.1.sogou.com/files/2016/10/28/58ddd5d610c0ce98a7ab0048314f20e5.png" alt=""><br>curTime表示该函数调用的时间点.<br>displayStartTime表示一连串启动Activity中的最后一个Activity的启动时间点.<br>mLaunchStartTime表示一连串启动Activity中第一个Activity的启动时间点.</p>
<p>正常情况下点击桌面图标只启动一个有界面的Activity，此时displayStartTime与mLaunchStartTime便指向同一时间点，此时ThisTime=TotalTime。另一种情况是点击桌面图标应用会先启动一个无界面的Activity做逻辑处理，接着又启动一个有界面的Activity，在这种启动一连串Activity的情况下，displayStartTime便指向最后一个Activity的开始启动时间点，mLaunchStartTime指向第一个无界面Activity的开始启动时间点，此时ThisTime！=TotalTime。这两种情况如下图：<img src="http://up.1.sogou.com/files/2016/10/28/ef7f63177f7a328da72704a35e78a6a9.png" alt="&quot;TotalTime/ThisTime的关系&quot;"><br>在上面的图中，我用①②③分别标注了三个时间段，在这三个时间段内分别干了什么事呢？</p>
<ol>
<li>在第①个时间段内，AMS创建ActivityRecord记录块和选择合理的Task、将当前Resume的Activity进行pause；</li>
<li>在第②个时间段内，启动进程、调用无界面Activity的onCreate()等、pause/finish无界面的Activity；</li>
<li>在第③个时间段内，调用有界面Activity的onCreate、onResume；</li>
</ol>
<p>看到这里应该清楚 ThisTime、TotalTime、WaitTime三个时间的关系了吧。WaitTime就是总的耗时，包括前一个应用Activity pause的时间和新应用启动的时间；ThisTime表示一连串启动Activity的最后一个Activity的启动耗时；TotalTime表示新应用启动的耗时，包括新进程的启动和Activity的启动，但不包括前一个应用Activity pause的耗时。也就是说，开发者一般只要关心TotalTime即可，这个时间才是自己应用真正启动的耗时。</p>
<p>Event log中TAG=am_activity_launch_time中的两个值分表表示ThisTime、TotalTime，跟通过“adb shell am start -W ”得到的值是一致的。</p>
<p>最后再说下系统根据什么来判断应用启动结束。我们知道应用启动包括进程启动、走Activity生命周期onCreate/onResume等。在第一次onResume时添加窗口到WMS(WindowManagerService)中，然后measure/layout/draw，窗口绘制完成后通知WMS，WMS在合适的时机控制界面开始显示(夹杂了界面切换动画逻辑)。记住是窗口界面显示出来后，WMS才调用reportLaunchTimeLocked()通知AMS Activity启动完成。</p>
<h4 id="1，应用层面的分析："><a href="#1，应用层面的分析：" class="headerlink" title="1，应用层面的分析："></a>1，应用层面的分析：</h4><p>当用户点击Launcher的Sogou Icon之后的动作，从一个App开发者角度看，要经历一下过程，才能展示在用户眼前：</p>
<hr>
<p> Launcher Icon  —&gt;  BrowserApp(Sogou Application)  —&gt;  BrowserActivity.onCreate()(Sogou Main Activity)  —&gt;  BrowserActivity.onResume()  —&gt;  showing</p>
<hr>
<p>以上就是搜狗浏览器在启动过程中的必经之路，从BrowserApp开始就是我们可以控制的启动过程了。尽量缩短从Launcher Icon —&gt;  Showing的时间是我们的目的。<br>将BrowserApp和BrowserActivity.onCreate()和BrowserActivity.onResume()非必要代码移到启动过程之后，精简主页面的布局结构，去掉非必要的层级嵌套。之后进行测试，也确实缩短了一些时间，但是不是太明显。再将不必要的层级，不必要的代码减无可减的情况下，启动时间的提升却很有限。我曾经尝试过把主页面的内容全部置空，确实启动时间有了质的提升，遂想先启动开BrowserActivity，然后在BrowserActivity.onResume()之后再去延迟渲染加载真实的主页面，但这样用户体验就会极差，用户会看到短暂的空白页，然后才能看到真实的主页面，优化冷启动速度的目的本是提高加载速度，以便让用户等待最短的时间就可以与APP进行交互。如果主页面延迟显示，不仅没有提升用户体验，反而让用户更能明显的感知到APP缓慢的启动过程，有点顾此失彼，本末倒置。</p>
<h5 id="观察竞品QQ浏览器"><a href="#观察竞品QQ浏览器" class="headerlink" title="观察竞品QQ浏览器:"></a>观察竞品QQ浏览器:</h5><p><img src="http://up.1.sogou.com/files/2016/10/28/2b3176e54a6fd2580e3057b44aa893e1.png" alt=""><br><img src="http://up.1.sogou.com/files/2016/10/28/43ff429382cea8c63ff7b91ff4ed80d3.png" alt=""></p>
<blockquote>
<p>Q浏览器新版的更改较大，稍后再说。但是在较早之前的版本，他们的页面如图所示，也不简单，但是他们能做到秒开，右图为QA提供的当时的测试数据直方图。</p>
</blockquote>
<p>在显示布局边界选项开启，反复启动QQ浏览器，你会发现一些现象：在启动后可见的极短时间内，整个界面的布局边界不会如上图所示，而是就显示了一个View的布局边界。而且，在这段时间内，浏览器是不响应任何事件的。所以，我们大胆的推测，QQ浏览器在启动的过程中，不是按部就班，老老实实的展示真实的页面的，而是先展示了一直图片，然后再使用真实的页面内容将其替换掉。<br>假设完，接下来就是要去求证。在同事通过编译Android ROM，在关键节点打印信息，通过分析，证实了我们的猜测，并且转存了他们截图，并替换成其他图片，QQ浏览器在接下来的启动过程中也确实显示的是我们偷梁换柱的图片。</p>
<h4 id="2，我们怎么做？："><a href="#2，我们怎么做？：" class="headerlink" title="2，我们怎么做？："></a>2，我们怎么做？：</h4><p>&emsp;&emsp;取证、验证完了，证明QQ浏览器就是这么做的，接下来要做的事情就是比着葫芦画瓢了。主页面截图，开机启动展示截图，并替换成真实的页面信息。这些都很easy。但是，关键点在于：截图和真实内容替换的时机，到底在什么时机完成狸猫换太子呢？？？<br>&emsp;&emsp;刚开始的想法：在BrowserActivity.onCreate()的开始，将截图贴上去，然后在BrowserActivity.onResume()通过Handler delay一定时间后再用真实页面去替换掉截图(之所以延时，是因为onResume距离页面可见还有一段时间间隔)。这样做确实是可以的，但是在delay多少时间的确定上就遇到了大麻烦，因为从onResume()到页面展示，中间的时长是和手机性能密切相关的，在高端机上需要0.5s，在低端机上就有可能需要5s，相差很大。我们不可能跟割韭菜一样，齐刷刷的一刀切，这样或许在低端机上对于冷启动速度有所提升，但是在高端机上，就等于人为的拉长加载时间。再说手机的配置，日新月异，整体Android市场的手机配置正在往高端靠拢，咱们不可能为了优化低端机上的表现，把所有高端机的性能拉低。<br>&emsp;&emsp;后来也想过保持delay的方案不变，通过动态的去配置delay的时间来保证高中低端机都有合适的delay时长。但是，仔细想就放弃了，android市场和ios市场不同，市面上的手机，千差万别，配置更是五花八门，我们不可能为所有的手机去指定delay时间，即使按照cpu，内存等参数，去指定粗略的delay时长也是非常耗时，耗人力的，遂放弃。</p>
<p>恰好彼时正在改版首页面的快链模块，由于要做快速链接的大改版，整体的效果跟Android  Launcher差不多，就是可以跨越多个屏幕进行icon的排序，整理，删除等功能。所以就参考了一些系统launcher的源代码，看到在LauncherModel中有许多地方用到MessageQueue中提供的IdleHandler，从字面理解就是空闲处理，源码关于这一块的处理如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</div><div class="line">-     ......</div><div class="line">-</div><div class="line">-     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">-         Looper me = myLooper();</div><div class="line">-         MessageQueue queue = me.mQueue;</div><div class="line">-</div><div class="line">-         ......</div><div class="line">-</div><div class="line">-         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">-             Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">-             ......</div><div class="line">-</div><div class="line">-             <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">-                 <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">-                     <span class="comment">// No target is a magic identifier for the quit message.</span></div><div class="line">-                     <span class="keyword">return</span>;</div><div class="line">-                 &#125;</div><div class="line">-</div><div class="line">-                 ......</div><div class="line">-</div><div class="line">-                 msg.target.dispatchMessage(msg);</div><div class="line">-</div><div class="line">-                 ......</div><div class="line">-</div><div class="line">-                 msg.recycle();</div><div class="line">-             &#125;</div><div class="line">-         &#125;</div><div class="line">-     &#125;</div><div class="line">-</div><div class="line">-     ......</div><div class="line">- &#125;</div></pre></td></tr></table></figure></p>
<p>Looper中是一个死循环，一直从MessageQueue中取Message，然后交给Handler去处理，当没有任何数据可以取得时候，循环会阻塞在MessageQueue.next()方法上，直到有新的数据，在CPP底层，通过Binder去通知上层，解除阻塞，继续循环取Message得操作。<br>而在MessageQueue中提供Message的next()方法内部实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</div><div class="line">-     ......</div><div class="line">-</div><div class="line">-     <span class="function"><span class="keyword">final</span> Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">-         <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">-         <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">-</div><div class="line">-         <span class="keyword">for</span> (;;) &#123;</div><div class="line">-             <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">-                 Binder.flushPendingCommands();</div><div class="line">-             &#125;</div><div class="line">-             nativePollOnce(mPtr, nextPollTimeoutMillis);</div><div class="line">-</div><div class="line">-             <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">-                 <span class="comment">// Try to retrieve the next message.  Return if found.</span></div><div class="line">-                 <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">-                 <span class="keyword">final</span> Message msg = mMessages;</div><div class="line">-                 <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">-                     <span class="keyword">final</span> <span class="keyword">long</span> when = msg.when;</div><div class="line">-                     <span class="keyword">if</span> (now &gt;= when) &#123;</div><div class="line">-                         mBlocked = <span class="keyword">false</span>;</div><div class="line">-                         mMessages = msg.next;</div><div class="line">-                         msg.next = <span class="keyword">null</span>;</div><div class="line">-                         <span class="keyword">if</span> (Config.LOGV) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</div><div class="line">-                         <span class="keyword">return</span> msg;</div><div class="line">-                     &#125; <span class="keyword">else</span> &#123;</div><div class="line">-                         nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(when - now, Integer.MAX_VALUE);</div><div class="line">-                     &#125;</div><div class="line">-                 &#125; <span class="keyword">else</span> &#123;</div><div class="line">-                     nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">-                 &#125;</div><div class="line">-</div><div class="line">-                 <span class="comment">// If first time, then get the number of idlers to run.</span></div><div class="line">-                 <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span>) &#123;</div><div class="line">-                     pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">-                 &#125;</div><div class="line">-                 <span class="keyword">if</span> (pendingIdleHandlerCount == <span class="number">0</span>) &#123;</div><div class="line">-                     <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></div><div class="line">-                     mBlocked = <span class="keyword">true</span>;</div><div class="line">-                     <span class="keyword">continue</span>;</div><div class="line">-                 &#125;</div><div class="line">-</div><div class="line">-                 <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">-                     mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">-                 &#125;</div><div class="line">-                 mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">-             &#125;</div><div class="line">-</div><div class="line">-             <span class="comment">// Run the idle handlers.</span></div><div class="line">-             <span class="comment">// We only ever reach this code block during the first iteration.</span></div><div class="line">-             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">-                 <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">-                 mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line">-</div><div class="line">-                 <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">-                 <span class="keyword">try</span> &#123;</div><div class="line">-                     keep = idler.queueIdle();</div><div class="line">-                 &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">-                     Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">-                 &#125;</div><div class="line">-</div><div class="line">-                 <span class="keyword">if</span> (!keep) &#123;</div><div class="line">-                     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">-                         mIdleHandlers.remove(idler);</div><div class="line">-                     &#125;</div><div class="line">-                 &#125;</div><div class="line">-             &#125;</div><div class="line">-</div><div class="line">-             <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">-             pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line">-</div><div class="line">-             <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">-             <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">-             nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">-         &#125;</div><div class="line">-     &#125;</div><div class="line">-</div><div class="line">-     ......</div><div class="line">- &#125;</div></pre></td></tr></table></figure></p>
<p>该方法在消息队列中没有消息或者消息的执行时间还没有到，都会使其进入线程等待，而在进入等待状态前会去处理mPendingIdleHandlers中的数据，而其中的数据，就是通过MessageQueue.addIdleHandler将其放入到mPendingIdleHandlers中去的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</div><div class="line">-     ......</div><div class="line">-</div><div class="line">-     <span class="comment">/**</span></div><div class="line">-     * Callback interface for discovering when a thread is going to block</div><div class="line">-     * waiting for more messages.</div><div class="line">-     */</div><div class="line">-     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</div><div class="line">-         <span class="comment">/**</span></div><div class="line">-         * Called when the message queue has run out of messages and will now</div><div class="line">-         * wait for more.  Return true to keep your idle handler active, false</div><div class="line">-         * to have it removed.  This may be called if there are still messages</div><div class="line">-         * pending in the queue, but they are all scheduled to be dispatched</div><div class="line">-         * after the current time.</div><div class="line">-         */</div><div class="line">-         <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</div><div class="line">-     &#125;</div><div class="line">-</div><div class="line">-     ......</div><div class="line">- &#125;</div></pre></td></tr></table></figure></p>
<p><strong>ok，整理以上内容：Handler通过轮询去处理MessageQueue中取出的数据，MessageQueue没有数据需要处理时，会进入wait状态，而在进入wait之前，会处理IdleHandler的东西。</strong></p>
<p>我们的想法就是，手机性能各有不同，所以，就让手机去执行该执行的任务，在任务完成，进入wait的时机，把我们的截图替换上去，然后手机还是去执行必要的加载任务(完成View的绘制)，然后在下一个wait到来的时机，再将截图去替换成真是的Views。</p>
<p>上述想法需要一个充分必要条件：App启动过程中的确有使主线程Handler进入wait的时间点，且这个点，到来的比较快，之前不会做太多App自己的动作。应用程序的启动过程比较复杂，且冗长。有兴趣可以看一下：<a href="老罗老师的博客，分析App启动过程">http://blog.csdn.net/luoshengyang/article/details/6747696</a>。这里只截取关键的几个点：</p>
<p>ActivityManagerService 通过调用ApplicationThread中的scheduleLaunchActivity去加载App默认的Activity，而这个scheduleLaunchActivity是在ActivityThread中实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</div><div class="line">-</div><div class="line">-     <span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</div><div class="line"></div><div class="line">-     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">-         ......</div><div class="line">-</div><div class="line">-        Looper.prepareMainLooper();</div><div class="line">-        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">-         thread.attach(<span class="keyword">false</span>);</div><div class="line">-        <span class="keyword">if</span>(sMainThreadHandler == <span class="keyword">null</span>)&#123;</div><div class="line">-              sMainThreadHandler = thread.getHandler();</div><div class="line">-        &#125;</div><div class="line">-         ......</div><div class="line">-     &#125;</div><div class="line"></div><div class="line">-      ......</div><div class="line">-     <span class="function"><span class="keyword">final</span>  Handler <span class="title">getHandler</span><span class="params">()</span></span>&#123;</div><div class="line">-       <span class="keyword">return</span> mH;</div><div class="line">-     &#125;</div><div class="line"></div><div class="line">-     <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;</div><div class="line">-</div><div class="line">-         <span class="comment">// we use token to identify this activity without having to send the</span></div><div class="line">-         <span class="comment">// activity itself back to the activity manager. (matters more with ipc)</span></div><div class="line">-         <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></div><div class="line">-                 ActivityInfo info, Bundle state, List&lt;ResultInfo&gt; pendingResults,</div><div class="line">-                 List&lt;Intent&gt; pendingNewIntents, <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward) &#123;</div><div class="line">-             ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</div><div class="line">-</div><div class="line">-             r.token = token;</div><div class="line">-             r.ident = ident;</div><div class="line">-             r.intent = intent;</div><div class="line">-             r.activityInfo = info;</div><div class="line">-             r.state = state;</div><div class="line">-</div><div class="line">-             r.pendingResults = pendingResults;</div><div class="line">-             r.pendingIntents = pendingNewIntents;</div><div class="line">-</div><div class="line">-             r.startsNotResumed = notResumed;</div><div class="line">-             r.isForward = isForward;</div><div class="line">-</div><div class="line">-             queueOrSendMessage(H.LAUNCH_ACTIVITY, r);</div><div class="line">-         &#125;</div><div class="line"></div><div class="line">-         <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">queueOrSendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</div><div class="line">-             <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">-                 ......</div><div class="line">-                 Message msg = Message.obtain();</div><div class="line">-                 msg.what = what;</div><div class="line">-                 msg.obj = obj;</div><div class="line">-                 msg.arg1 = arg1;</div><div class="line">-                 msg.arg2 = arg2;</div><div class="line">-                 mH.sendMessage(msg);</div><div class="line">-             &#125;</div><div class="line">-         &#125;</div><div class="line">-       <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">-</div><div class="line">-            ......</div><div class="line">-</div><div class="line">-            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">-             ......</div><div class="line">-             <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">-             ......</div><div class="line">-             &#125;</div><div class="line">-</div><div class="line">-            ......</div><div class="line">-</div><div class="line">-     &#125;</div><div class="line">-</div><div class="line">- &#125;</div></pre></td></tr></table></figure></p>
<p>这里首次出现了往主线程的Handler发送信息的queueOrSendMessage，其方法内部将ActivityClientRecord 封装成Message，然后发送给mH这个Handler。而这个mH就是ActivityThread的私有类，应用进程启动之后，就会加载ActivityThread的main方法，这时候就是创建ActivityThread的对象，并在此工程中创建mH的对象，接下来的步骤，比较复杂：<br>一般View往主线程发送Runnable的作法如下：<br><img src="http://up.1.sogou.com/files/2016/10/28/024bd2f96812848a7c6e438006f59a02.png" alt=""><br>那么这个AttachInfo的mHandler就是主线程的Handler，就是上文中提到的mH。</p>
<p>Activity和View的交互，是通过WindowManager来实现的，WindowManager创建PhoneWindow负责View的添加、删除和View的各种其他声明周期方法，而这个WindowManager其实是一个SystemService，其是在Context的具体实现类ContextImpl中创建的：<br><img src="http://up.1.sogou.com/files/2016/10/28/e87da139b8132b4bcd03ab41da8b8324.png" alt=""><br>这样就把ActivityThread创建的MainHandler传递给了WindowManager，然后WindowManager创建PhoneWindow，再然后PhoneView创建DecorView和ViewRootImpl，在再然后往DecorView添加子View的时候，MainHandler就会作为AttachInfo的变量，在View attachToWindow的时候传递给子View(这也就解释了为什么在添加完View就调用View的post方法会失败的原因)。<br>就是ActivityThread执行Application，和Activity的生命周期，其中也会用到这个mH，然后走到Activity的onCreate，然后将App的Layout attach to DecorView，如果Layout本身添加了动画，也会使用到mH。添加Layout之后，如果没有业务逻辑，此时，mH 就马上要进入wait状态了，这就是一个好的时机。</p>
<p>&emsp;&emsp;所以，为了让App主线程的mH尽早的进入wait状态，要尽量保证，在Application生命周期，Activity启动的生命周期的各种回调不做耗时操作，尽量不使用mH去做事情；将Layout尽量简化，去掉不必要的动画。然后在此时，把IdleHandler塞给MessageQueue，让mH有机会去处理。</p>
<h4 id="3，搜狗浏览器的实践："><a href="#3，搜狗浏览器的实践：" class="headerlink" title="3，搜狗浏览器的实践："></a>3，搜狗浏览器的实践：</h4><p>&emsp;&emsp;搜狗浏览器的做法就是：BrowserApp和BrowserActivity.onCreate中，减少或者延时耗时操作。不使用主线程的Handler，将BrowserActivity的根layout，开始时设置为一个空的FrameLayout，并将上一次退出时保存的首页截图mScreenShotImage add 到这个空的FrameLayout中，scaleType = “fitXY”。然后App启动回调到BrowserActivity.onCreate时，先将包含截图的空FrameLayout直接add 到 ViewRoot(id=android.R.id.content的根ViewGroup)。然后再把替换Views 的步骤包装成IdleHandler塞给Hanlder。紧接着在完成Views绘制之后，包装一个去掉截图空FrameLayout的IdleHandler到Handler中，让其执行用来完成图片的替换过程，至此完成整个启动。<br><img src="http://up.1.sogou.com/files/2016/10/28/1fe07e3db0db534b4df56cbde4342bec.png" alt="&quot;贴上一个空FrameLayout的同时，将真实UI初始化方法initUI()放到一个IdleHandler中，等待被主UI的Handler空闲时执行&quot;"></p>
<h5 id="initUI-Bundle-："><a href="#initUI-Bundle-：" class="headerlink" title="initUI(Bundle)："></a>initUI(Bundle)：</h5><p><img src="http://up.1.sogou.com/files/2016/10/28/f2d8859d34d7635998042f3634c809f4.png" alt="&quot;initUI()方法完成的最后，将去掉空FrameLayout的步骤放到一个IdelHandler中，等待被主UI的Handler空闲时执行&quot;"></p>
<h5 id="其中，MainHandler就是主线程的Handler，mBrowserFrameLayout就是那个空架子，mScreenShotImage就是上一次的App-Home页面截图。"><a href="#其中，MainHandler就是主线程的Handler，mBrowserFrameLayout就是那个空架子，mScreenShotImage就是上一次的App-Home页面截图。" class="headerlink" title="其中，MainHandler就是主线程的Handler，mBrowserFrameLayout就是那个空架子，mScreenShotImage就是上一次的App Home页面截图。"></a>其中，MainHandler就是主线程的Handler，mBrowserFrameLayout就是那个空架子，mScreenShotImage就是上一次的App Home页面截图。</h5><h5 id="MainHandler中的waitForIdle实现如下："><a href="#MainHandler中的waitForIdle实现如下：" class="headerlink" title="MainHandler中的waitForIdle实现如下："></a>MainHandler中的waitForIdle实现如下：</h5><p><img src="http://up.1.sogou.com/files/2016/10/28/dda45874fe5975d420851a5ab8daa57a.png" alt=""><br><img src="http://up.1.sogou.com/files/2016/10/28/6ef44346f7024d5157d622f44d1a5539.png" alt=""></p>
<h5 id="Looper-getQueue-会报错是因为我们的应用要兼容低版本Android，而getQueue-这个方法是Api23以上才公开的方法，不过不用担心，因为追溯到Android2-3的手机上，Framework的层Looper实现中都是有getQueue-这个方法的，只是低版本都是private的。"><a href="#Looper-getQueue-会报错是因为我们的应用要兼容低版本Android，而getQueue-这个方法是Api23以上才公开的方法，不过不用担心，因为追溯到Android2-3的手机上，Framework的层Looper实现中都是有getQueue-这个方法的，只是低版本都是private的。" class="headerlink" title="Looper.getQueue()会报错是因为我们的应用要兼容低版本Android，而getQueue()这个方法是Api23以上才公开的方法，不过不用担心，因为追溯到Android2.3的手机上，Framework的层Looper实现中都是有getQueue()这个方法的，只是低版本都是private的。"></a>Looper.getQueue()会报错是因为我们的应用要兼容低版本Android，而getQueue()这个方法是Api23以上才公开的方法，不过不用担心，因为追溯到Android2.3的手机上，Framework的层Looper实现中都是有getQueue()这个方法的，只是低版本都是private的。</h5><p>关于截图的时机，我们现在是在App退出的回调去执行的。</p>
<h4 id="关于横竖屏启动，截图使用可能错误：竖着启动，可能使用上次退出横屏的截图；反之也是类似的情况。对比了QQ浏览器，我们采用了相同的做法，只是用竖屏截图，横屏下退出不截图。然后如果用户横屏启动，要加一点额外的处理："><a href="#关于横竖屏启动，截图使用可能错误：竖着启动，可能使用上次退出横屏的截图；反之也是类似的情况。对比了QQ浏览器，我们采用了相同的做法，只是用竖屏截图，横屏下退出不截图。然后如果用户横屏启动，要加一点额外的处理：" class="headerlink" title="关于横竖屏启动，截图使用可能错误：竖着启动，可能使用上次退出横屏的截图；反之也是类似的情况。对比了QQ浏览器，我们采用了相同的做法，只是用竖屏截图，横屏下退出不截图。然后如果用户横屏启动，要加一点额外的处理："></a>关于横竖屏启动，截图使用可能错误：竖着启动，可能使用上次退出横屏的截图；反之也是类似的情况。对比了QQ浏览器，我们采用了相同的做法，只是用竖屏截图，横屏下退出不截图。然后如果用户横屏启动，要加一点额外的处理：</h4><p><img src="http://up.1.sogou.com/files/2016/10/28/41197bbe6ca78f6dd6fcbcb889776117.png" alt="&quot;横竖屏启动时，使用截图时的处理细节&quot;"></p>
<h4 id="最后，还有一些细枝末节的处理，因为作为浏览器，会比普通App的调用场景更复杂多变一些。"><a href="#最后，还有一些细枝末节的处理，因为作为浏览器，会比普通App的调用场景更复杂多变一些。" class="headerlink" title="最后，还有一些细枝末节的处理，因为作为浏览器，会比普通App的调用场景更复杂多变一些。"></a>最后，还有一些细枝末节的处理，因为作为浏览器，会比普通App的调用场景更复杂多变一些。</h4><h4 id="最终结果还是比较令人满意的：Duang"><a href="#最终结果还是比较令人满意的：Duang" class="headerlink" title="最终结果还是比较令人满意的：Duang~~~"></a>最终结果还是比较令人满意的：Duang~~~</h4><p><img src="http://up.1.sogou.com/files/2016/10/28/44cce1e038a1f6f5325d634a3d539c3a.png" alt="&quot;冷启动优化测试直方图&quot;"></p>
<p>先就这么多吧。：P</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/myself.jpg"
               alt="lyhighfly" />
          <p class="site-author-name" itemprop="name">lyhighfly</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives">
            
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lyhighfly</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  








  








  





  

  

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.2"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.2"></script>


  

</body>
</html>
